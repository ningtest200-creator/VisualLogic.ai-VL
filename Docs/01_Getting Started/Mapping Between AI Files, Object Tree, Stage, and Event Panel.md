# Mapping Between AI Files, Object Tree, Stage, and Event Panel

## 1. Purpose of This Document

VisualLogic provides multiple ways to view and work with the same project:

- File-based VL code
- Structured object views
- Visual logic editing
- Runtime visual preview

These are **not separate systems** and are not optional alternatives.
 They are **different representations of the same project semantics**, kept consistent by the IDE.

This document explains **how AI Files, Object Tree, Stage, and Event Panel map to each other**, what each layer is responsible for, and how changes propagate across them.

Understanding this mapping is essential for correctly using AI-driven development, visual logic editing, and full-stack application building in VisualLogic.

------

## 2. One Project, Multiple Equivalent Representations

A VisualLogic project exists simultaneously in **two equivalent forms**:

1. **VL Code (AI Files)** — a textual, language-level representation
2. **Visual Editors (Object Tree & Event Panel)** — structured, human-friendly representations

Both forms describe the **same underlying system**.

There is no “code mode” and “visual mode” distinction in terms of capability.
 Any project that can be expressed in VL code can also be fully expressed through the visual editors.

The IDE guarantees **semantic equivalence** between these representations.

------

## 3. AI Files: Language-Level Definition

### 3.1 What AI Files Represent

AI Files contain the **formal VL language representation** of a project.

They define:

- Objects (frontend and backend)
- Object hierarchy and ownership
- Properties and configuration
- Event definitions
- Event handling logic
- Backend service logic
- Data flow and pipelines

AI Files are:

- Generated by AI
- Editable by developers
- Parsed by the compiler
- Exportable as final project source

They are the **authoritative language form** of the project.

------

### 3.2 Why AI Files Exist Even with Visual Editors

AI Files serve three critical purposes:

1. **AI-first development**
    AI generates and reasons about VL code directly.
2. **Formal compilation input**
    The compiler consumes VL code, not visual graphs.
3. **Interchange and portability**
    Projects can be exported, versioned, shared, and re-imported as files.

However, AI Files are **not optimized for human editing at scale**, especially for complex logic.
 That is why visual editors exist.

------

## 4. AI Files ↔ Object Tree Mapping

### 4.1 Object Tree as Object-Level Visualization

The **Object Tree** is the structured visualization of **object definitions declared in VL code**.

Every object declared in AI Files has a **direct, one-to-one representation** in the Object Tree.

This includes:

- Frontend objects
- Backend objects
- Containers
- Components
- Service domains
- Data-related objects

------

### 4.2 Mapping Rules

The mapping between AI Files and the Object Tree follows strict rules:

- VL object declarations → Object Tree nodes
- Parent–child relationships in VL → Tree hierarchy
- Object identifiers in VL → Node identity in the tree
- File boundaries → Application-level tree separation

Each application has its **own Object Tree**.
 There is no project-wide shared object tree.

------

### 4.3 Bidirectional Consistency

The Object Tree is not an independent data model.

- Changes to object structure in AI Files are reflected in the Object Tree
- Structural operations in the Object Tree update the corresponding VL definitions

The Object Tree exists to make **object structure readable and navigable**, not to introduce new semantics.

------

## 5. Object Tree ↔ Stage Mapping

### 5.1 Role of the Stage

The **Stage** is a **visual preview surface**.

It renders the **resolved frontend object structure** defined by:

- AI Files (VL code)
- Object Tree hierarchy
- Property configuration

The Stage shows how the application **appears at runtime**.

------

### 5.2 What the Stage Displays

The Stage visualizes:

- Layout containers
- Visual components
- Size and positioning
- Relative and absolute layout effects
- Rendering results of current state

Every visible element on the Stage corresponds to **one frontend object** in the Object Tree.

------

### 5.3 What the Stage Is Not

The Stage:

- Is not a source of truth
- Is not a structural editor
- Is not a logic editor

It exists solely to **verify and preview results**, allowing developers to see the impact of structure, properties, and logic.

------

## 6. AI Files ↔ Event Panel Mapping (Core Logic Layer)

### 6.1 Event Panel as the Primary Logic Editor

The **Event Panel** is the **primary environment for editing logic** in VisualLogic.

It is:

- Fully **Turing-complete**
- Capable of expressing complex logic, conditions, loops, and pipelines
- Used to edit **frontend interaction logic**
- Used to edit **backend service logic**

The Event Panel is not a simplified abstraction.
 It represents the **full expressive power of VL logic**, in a visual form.

------

### 6.2 Event Logic in AI Files

In AI Files, event logic is expressed using VL syntax:

- Event declarations
- Event handlers
- Service calls
- Variable assignments
- Conditional logic
- Pipeline execution

These definitions are **language-level expressions** of logic.

------

### 6.3 Visual Transformation

The IDE transforms VL event logic into a **visual logic graph** in the Event Panel.

This transformation:

- Preserves full semantics
- Does not reduce expressive power
- Makes control flow and data flow easier to understand

The Event Panel exists because **visual logic is more readable and safer to edit** than raw code for complex systems.

------

### 6.4 Bidirectional Synchronization

The relationship between AI Files and the Event Panel is **bidirectional**:

- VL event logic → visualized in the Event Panel
- Visual edits in the Event Panel → serialized back into VL code

There is no “lossy conversion”.

VL code and visual logic are **two equivalent representations of the same logic**.

------

## 7. Object Tree ↔ Event Panel Mapping

### 7.1 Structural Anchor for Logic

Event logic is always bound to **specific objects**.

- Events belong to frontend objects or backend service objects
- The Object Tree defines the scope and ownership of logic
- Each Event Panel context corresponds to a selected object

Removing or restructuring an object changes the available event scope.

------

### 7.2 Navigation and Indicators

The Object Tree provides visual indicators for:

- Objects with event handlers
- Objects with property bindings

These indicators serve as **entry points** into the Event Panel, linking structure and behavior.

------

## 8. Unified Frontend and Backend Logic Model

VisualLogic uses **one unified logic model**.

- Frontend events (clicks, input, UI state changes)
- Backend services (data processing, queries, transactions)

are all edited using the **same Event Panel paradigm**.

The difference lies in:

- Execution context
- Available system APIs
- Runtime environment

not in the logic model itself.

This is a core reason VisualLogic can support **full-stack development without context switching**.

------

## 9. Change Propagation Model

Changes propagate through the system as follows:

| Change Location    | Propagates To                        |
| ------------------ | ------------------------------------ |
| AI Files (VL Code) | Object Tree, Event Panel, Stage      |
| Object Tree        | Stage, Event Panel                   |
| Event Panel        | AI Files (VL Code), runtime behavior |
| Stage              | No source modification               |

This guarantees:

- No divergence between representations
- No hidden runtime-only state
- Deterministic project behavior

------

## 10. Correct Mental Model

The correct way to think about VisualLogic is:

- **AI Files define the language-level system**
- **Object Tree visualizes object structure**
- **Event Panel visualizes and edits logic**
- **Stage previews runtime appearance**

Or more simply:

> **Code and visual editors are two synchronized views of the same project.**

------

## 11. Final Clarification

VisualLogic is not “visual programming instead of code”.

It is a system where:

- AI primarily operates on code
- Humans primarily operate on visual structure and logic
- The IDE guarantees consistency between both

This design enables **AI-first development**, **complex logic editing**, and **full-stack application creation** without sacrificing correctness or expressive power.
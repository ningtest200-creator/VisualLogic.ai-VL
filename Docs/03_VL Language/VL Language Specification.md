# VL Language Specification (Core) — AI-First, Component-Oriented, IDE Round-Trip (Draft v2.3)

## 1. What VL Is

VL is a **component-oriented programming language** designed for **AI-first development** and **lossless round-trip conversion** with an **event-driven, component-interaction logic visualization IDE** (not “node-based” in the generic sense).

VL source code is a **deterministic, canonical serialization** of the program’s structure, so it can be:

* **Hand-written as VL code**
* **Generated by AI (low token, high precision)**
* **Built fully in the graphical IDE**
  …and always converted back and forth without ambiguity.

---

## 2. Design Principles

### 2.1 Minimal Logic, Maximum Clarity

VL intentionally avoids “clever” syntax. It prefers **simple, explicit logic** with a small set of primitives, so both AI and humans can produce correct code consistently.

* Formatting is strict and canonical to eliminate ambiguity and stabilize generation/parsing (e.g., mandatory single-line constructs).
* The language enforces constraints that reduce architectural drift and “creative” code that is hard for AI to maintain.

### 2.2 Data-Driven Frontend, Event-Driven Behavior

* **Frontend is data-driven**: UI properties bind to variables; to change UI, you change upstream state.
* **Behavior is event-driven**: events are bound explicitly and execute handler logic on trigger.
* No hidden magic: for input bindings, VL has **no v-model style syntactic sugar**—updates are explicit via events.

### 2.3 Components Are the Fundamental Unit

A **component** is the smallest programmable unit in VL. Every frontend and backend component is defined by:

* **Properties** (inputs/state bindings)
* **Events** (interaction & notifications)
* **Methods** (callable procedures)

Developers can compose **platform components** or build **encapsulated custom components**.

---

## 3. IDE ⇄ VL Code Round-Trip (Core Guarantee)

VL is designed so a VL file maps cleanly to a corresponding “block” in the IDE’s object tree:

* Each file has a **root component** and a set of **fixed sections**.
* Each section corresponds to a specific IDE region (tree, handlers, methods, services, etc.).
* The canonical formatting rules ensure stable serialization, enabling reliable conversion in both directions.

**Strict section structure** is required: sections must appear **in order and only once**, or compilation fails.

---

## 4. Project Structure and Dependency Model

### 4.1 File Kinds

VL commonly uses:

* `.vx` App
* `.sc` Section (business module)
* `.cp` Component (reusable UI unit)
* `.vs` ServiceDomain (backend domain + services)
* `.vdb` Database schema
* `.vth` Theme (design tokens + style classes)

### 4.2 Dependency Rules (Architecture Guardrails)

VL enforces a constrained reference model to keep architecture predictable:
App → (Section, Component); Section → (ServiceDomain, Component); Component and ServiceDomain are isolated.

A standard three-tier responsibility split is encouraged (App / Section / Component).

---

## 5. Core Syntax (Canonical Form)

### 5.1 Version Declaration (Required)

Every file begins with a version declaration comment so the parser selects the correct rules.

### 5.2 Indentation and Structure

* VL uses `-` (hyphen) indentation, **no leading spaces**.
* Tree hierarchy is expressed through `-` depth.
* Method/event bodies are also structured by `-` indentation.

### 5.3 Single-Line Rule (Mandatory)

Many definitions/statements must be written on **one line** (variables, signatures, RETURNs, assignments, component props), otherwise compilation fails.

### 5.4 Strings: No Backslash Escapes

VL Core forbids `\` escape characters anywhere; this is a hard compilation constraint.

---

## 6. Programming Model

### 6.1 Variables and State

* Global state variables use `$...`
* Local variables use `_...`
* Derived variables are computed, and participate in strict unidirectional flow.

### 6.2 Events

* Public events must be declared before being triggered.
* Event handlers have a strict “listener line + indented body” structure.

### 6.3 Methods and Reuse

VL encourages keeping logic **direct**:

* If logic is used only once, write it inline; only extract internal methods when reused across multiple places.

### 6.4 Expressions and Purity

To keep reasoning and generation stable:

* **METHOD / METHOD\_PUB may not be called inside expressions**; use pure PIPE functions instead.
* Parentheses are mandatory for operator expressions (no precedence guessing).

---

## 7. Backend as Programmable Cloud Components

VL treats backend capabilities as **ServiceDomain components**:

* A ServiceDomain defines backend resources (e.g., virtual tables) and exposes callable **services**.
* Sections call ServiceDomain services directly, enabling AI or users to assemble full-stack behavior with minimal glue.

This enables a “cloud products as components” model: backend resources are callable, composable, and can be integrated pay-as-you-go through the platform’s component layer (product design goal).

---

## 8. AI-First Generation and Agents

VL is designed so an **Agents system** can generate complete applications (frontend + backend) reliably because:

1. The language is constrained and deterministic (stable formatting + strict sections).
2. Architecture guardrails prevent “LLM drift” into inconsistent patterns.
3. Frontend is data-driven and event handlers are explicit, reducing implicit coupling.

VL targets the current AI coding bottlenecks you listed:

* Too flexible syntax & legacy paradigms → noisy outputs, high tokens, fragile architecture
* Hard to scale to complex apps end-to-end
* Backend resources are not directly programmable as first-class building blocks

VL’s answer is **componentization + determinism + direct backend component access**.

---

## 9. Licensing

VL syntax and specification are **fully open-sourced under MIT** (project policy statement).

---

## Minimal Example (Illustrative)

```vl
// VL_VERSION:2.2
<Section-SearchResults "root">

# Frontend Global Vars
$show(BOOL) = false
$currentCourseId(STRING) = ""

# Frontend Tree
<Button-Close "closeBtn"> text:"Close" show:$show

# Frontend Event Handlers
<Button-Close "closeBtn">.@click()
-$show = false

</Section-SearchResults>
```

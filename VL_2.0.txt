# VL 语法规则参考

## 版本声明

```vl
// VL_VERSION: 版本号
```

此版本声明必须位于所有文件的第一行注释中，确保解析器使用正确的版本规则。

当前版本: `// VL_VERSION:2.0`

注意：版本声明并不是一个VL代码章节，请使用 `//`而不是 `#`

## 文件类型与结构

### 项目文件树结构：

```
Workspace/
├─ Services/              # ServiceDomain文件（服务域定义，可在Section中调用）
│   ├─ Catalog.vs
│   └─ Order.vs
├─ Database/              # Database文件（数据库结构定义）
│   └─ MyProject.vdb
├─ Sections/                 # Section文件（前端视图模块,仅能在App中使用）
│   ├─ NavHeader.sc
│   ├─ UserProfile.sc
│   ├─ ProductCard.sc
│   └─ OrderList.sc
├─ ExtComponents/         # Component文件（内部封装组件，可在Section/App中使用）
│   ├─ InputField.cp
│   └─ DataAuth.cp
├─ Theme/                 # Theme文件（项目视觉规范，颜色、字体、间距等 Token以及预置组件样式定义，全项目仅一个Theme文件）
│   └─ MyProject.vth   
└─ Apps/                 # App文件（一个应用一个文件）
    ├─ ShopApp.vx   
    └─ AdminApp.vx
```

所有文件均参与最终项目代码编译。

### 文件的相互引用

VL中的代码文件支持一定程度的相互引用，请严格遵守以下规则：

|                     | App | Section | ServiceDomain | Component |
| ------------------- | --- | ------- | ------------- | --------- |
| App中可引用         | ❌  | ✅      | ❌            | ✅        |
| Section中可引用     | ❌  | ❌      | ✅            | ✅        |
| Component中可引用   | ❌  | ❌      | ❌            | ❌        |
| ServiceDomain可引用 | ❌  | ❌      | ❌            | ❌        |

### 文件内段落与结构示例

VL文件遵守严格的段落划分，**所有段落必须按顺序出现且仅出现一次**，否则无法编译。

#### 1. `.vx` — App（应用入口）

**必须段落**：`# SysConfig`、`# Frontend Tree`、`# Frontend Event Handlers`

```vl
// VL_VERSION:版本号
<App-MarkdownEditApp "root">

# SysConfig
DEVICE_TARGET:"PC"
SCREEN_RESOLUTION:"1920x1080"

# Frontend Global Vars
$currentDocId(INT) = -1

# Frontend Derived Vars
$docIdString(STRING) = ("Doc ID " + $currentDocId)

# Frontend Tree
<Page-Home "homePage"> path:"home" styleClass:..
-<Section-DocumentList "docList">

# Frontend Event Handlers
<Section-DocumentList "docList">.@docSelected(docId, title)
-$currentDocId = docId

# Frontend Internal Methods
# Frontend Pipeline Funcs
</App-MarkdownEditApp>
```

**尺寸控制**：Header `flex:"0 0 64px"`、Sidebar `flex:"0 0 240px"`、Main `flex:"1"`

#### 2. `.sc` — Section（业务模块）

**核心特性**：可调用ServiceDomain、使用Component、包含完整业务逻辑
**禁止**：嵌套Section

**必须段落**：`# Frontend Tree`、`# Frontend Event Handlers`

```vl
// VL_VERSION:版本号
<Section-NavHeader>

# Frontend Public Props
$userId(INT) = 0

# Frontend Global Vars
$userInfo({name:STRING,avatar:STRING}) = {name:"",avatar:""}

# Frontend Derived Vars
$displayName(STRING) = ($userInfo.name != "" ? $userInfo.name : "Guest")

# Frontend Tree
<ServiceDomain-User "userService">
-<Service-GetUserInfo> params:(userId(INT)) returns:(success(BOOL),data({}))
<Row-HeaderContainer> width:100% height:64px
-<Component-UserAvatar> userId:$userId avatar:$userInfo.avatar
-<Button-Logout "logoutButton"> value:"Logout"

# Frontend Public Events
EVENT @userLoggedOut()

# Frontend Public Methods
METHOD_PUB RefreshUserInfo();RETURN {success:BOOL}
-<ServiceDomain-User "userService">.GetUserInfo($userId) -> _result
-RETURN {success:_result.success}

# Frontend Event Handlers
<Button-Logout "logoutButton">.@click()
-@userLoggedOut()

# Frontend Internal Methods
# Frontend Pipeline Funcs
</Section-NavHeader>
```

#### 3. `.cp` — Component（纯UI组件）

**核心特性**：仅UI复用、数据通过Props传入、通过Events通信
**禁止**：引入ServiceDomain、嵌套Component、复杂业务逻辑

**必须段落**：`# Frontend Tree`、`# Frontend Event Handlers`

```vl
// VL_VERSION:版本号
<Component-UserCard>

# Frontend Public Props
$userId(INT) = 0
$userName(STRING) = ""

# Frontend Global Vars

# Frontend Derived Vars
$displayName(STRING) = ($userName != "" ? $userName : ("User " + $userId))

# Frontend Tree
<Block-CardContainer> width:280px
-<Text-UserName> value:$displayName
-<Button-Action "actionButton"> value:"Details"

# Frontend Public Events
EVENT @cardClick(userId(INT))

# Frontend Public Methods

# Frontend Event Handlers
<Button-Action "actionButton">.@click()
-@cardClick($userId)

# Frontend Internal Methods

# Frontend Pipeline Funcs
</Component-UserCard>
```

**对比**：Section负责业务+数据加载，Component负责纯UI展示

#### 4. `.vs` — ServiceDomain（后端服务域）

**必须段落**：`# Backend Tree`、`# Services`

```vl
// VL_VERSION:版本号
<ServiceDomain-Doc>

# Backend Tree
<VirtualTable-DocList "docTable"> sourceTable:Documents
-<Field-title> type:STRING
-<Field-content> type:STRING

# Services
SERVICE GetDocList();RETURN {success:BOOL,data:[{}]}
-<VirtualTable-DocList "docTable">.select(null,[["_update","desc"]],[0,100]) -> _r
-RETURN {success:true,data:_r.dataArray}

# Backend Event Handlers
# Transactions
# Backend Internal Methods
# Backend Pipeline Funcs
</ServiceDomain-Doc>
```

#### 5. `.vdb` — Database（数据库结构）

```vl
// VL_VERSION:版本号
<Database-ProjectName>
<Table-Documents> data:[{"_id":1,"title":"Doc1","_create":"2024-01-15 09:30:00"}]
-<Field-title> type:STRING notNull:true
-<Field-content> type:STRING
-<Index-TitleIdx> type:UNIQUE fields:["title"]
<Relation-User&Docs> users._id<<documents._user
</Database-ProjectName>
```

#### 6. `.vth` — Theme（主题配置）

**规则**：单例文件、仅新增Token不可删改; Design Tokens中，每一行代表一个Token Group，一个Token Group由多个Token构成；Component Styles中定义了所有基础组件的预置样式类，样式值优先使用Design Token

```vl
// VL_VERSION:版本号
<Theme-ProjectName>
# Design Tokens
<Color-Brand> colorBrandPrimary:#0052D9 colorBrandPrimaryHover:#366EF4 ...
<Size-Height> heightXs:20px heightSm:24px ...
...

# Component Styles
<Button-Primary> background-color:--colorBrandPrimary padding:--spacing4
-<StateStyle-Hover> trigger:hover background-color:--colorBrandHover
</Theme-ProjectName>
```

## 核心语法约束 (全局适用)

VL 遵循严格的格式化规则以确保代码的一致性和可解析性。以下约束全局适用，除非特定组件或语法有明确例外：

#### 单行规则（强制）

许多定义和语句**必须**在单一行内完成，不允许换行。这包括但不限于：

* 变量定义 (全局 `$var(...) = ...`, 局部 `_var(...) = ...`, `_var({}) = {}`, `_var([]) = []`)。
* 方法、服务、事件、管道的定义行 (即第一行，包含所有参数和 `RETURN` 声明)。
* 所有 `RETURN {...}` (对于 METHOD/SERVICE) 或 `RETURN value` (对于 PIPE) 语句。
* 所有赋值语句 (`$var = ...`, `_var = ...`)。
* 对象和数组的初始化赋值（即使结构复杂）。
* 组件属性的单行定义 (即使有多个属性用空格分隔，也仍在同一行)。

违反此规则将导致编译错误。后续各节中将不再为每个适用情况重复强调"单行规则"，请开发者牢记此全局约束。

#### 无前导空格与定格输出规则（强制）

* 所有表示层级结构的 `-` (减号/连字符) 符号，都**必须顶格输出**，其前面不允许有任何空格。
* 实际上，VL语法中，只要某行有内容，所有内容之前均**不应出现空格**（JSON代码块或特定嵌入式语言除外）。

#### 分号（;）用法（严格）

* 分号也用于 `FOR` 计数循环的控制部分分隔符 (e.g., `FOR (_i(INT)=0; _i<10; _i++)`)。
* **禁止**在普通代码行的行尾（如变量赋值、方法调用、RETURN语句后）使用分号。
* **禁止**在样式性属性之间或最后一个样式性属性后使用分号。

#### 字符串的转义

**严禁使用任何 `\`转义符！严禁在任何地方使用 `\`转义符！输出前请检查去掉所有 `\`转义符！**

重要的事情说三遍！否则会导致程序严重编译错误！！

#### 缩进

VL中通过无空格的"-"表示缩进：

* **顶层定义 (无缩进):** 根组件 (`<Section-..>`), 段落标题 (`# Frontend Global Vars`, `# Services`, `# Frontend Tree`, etc.), 以及方法/服务/事件/管道的定义行 (`METHOD...`, `SERVICE...`, `EVENT...`, `PIPE...`) 通常位于代码文件的最左侧，没有前导 `-`。
* **Frontend Tree:**
  * 直接添加在根下的组件直接写组件名，无前导 `-` 。
  * 子组件，每深一层，在行首增加一个 `-`。例如：
    ```vl
    <Block-Header>
    -<Text-Title> value:"Title"
    <Block-Content>
    -<Button-Submit> value:"Submit"

    <VirtualTable-Users> ..
    -<Field-_id> ... // Field为VirtualTablee子组件
    ```
* **方法/事件处理器内部:**
  * 方法/事件处理器的主体代码块，所有行都必须至少缩进一级 (以 `-` 开头)。
  * 控制流结构 (`IF`, `FOR`块) 会引入更深的缩进层级。

#### 段落标记与注释

`#`表示标准段落结构标记 (如 `# Frontend Tree`, `# Frontend Default Styles`)，注意请根据当前文件的开发规范，严格遵守预设的段落结构以及顺序。

`//`表示行内注释和行间注释。

`/*`与 `*/`代表块注释。

例如：

```vl
// VL_VERSION:版本号

<Section-antUploadDragger>
/*
这个模块主要用于模拟 Ant Design 中 UploadDragger 组件。
*/

# Frontend Global Vars
$uploadedFiles([{uid:STRING,name:STRING,status:STRING,url:STRING,size:INT}]) = []

</Section-antUploadDragger>
```

## 命名规范

#### 文件命名：

所有文件名统一为PascalCase，且与根组件保持一致：

`UserAuth.vs` 文件，根组件为：

```
<ServiceDomain-UserAuth>
文件体
</ServiceDomain-UserAuth>
```

#### **组件实例命名**:

- 组件名称使用 **PascalCase** (大驼峰) 命名法 (e.g., `UserCard`, `LoginButton`, `NoteItemCard`, `AddButton`)。
- 组件名称应反映组件用途。
- 组件ID使用小驼峰，组件ID请尽量反应组件的用途和类型，比如 `<Button-Submit "submitButton">`,`<Block-ModuleRoot "root">`,`<VirtualTable-Users "userTable">`

#### **变量命名**

- **前端全局变量** (`# Frontend Global Vars`): `$` 前缀 + **camelCase** (小驼峰) (e.g., `$currentPage`, `$userData`)。
- **派生变量** (`# Frontend Derived Vars`): `$` 前缀 + **camelCase** (e.g., `$fullName`, `$canSubmit`)。
- **方法内创建的局部变量** (`_varName(TYPE) = ...` 或 `_varName({}) = {}` 或 `_varName = []`): 统一使用 `_` 前缀 + **camelCase** (e.g., `_result`, `_tempData`)。**必须**声明类型或通过空结构推断，**无** `let` 关键字。
- **循环变量**:
  - 循环变量是一种"**特殊的局部变量**"，可以不用定义直接使用。
  - `FOR...IN` 循环: 循环项变量和索引变量**必须**使用 `_` 前缀 + **camelCase**. 索引变量建议使用 `_indexX` (X 从 0 开始递增, e.g., `_index0`, `_index1`). 循环项变量可以根据上下文命名 (e.g., `_user`, `_product`, `_noteItem`) 或使用 `_itemX` 进行通用迭代 (e.g., `_item0`, `_item1`, `_item2`)。例如: `FOR (_user, _index0) IN $userList` 或 `FOR (_item0, _index0) IN dataArray`。
  - `FOR (...)` 计数循环: 循环控制变量（如 `i`, `j`, `k` 或更有意义的名称如 `counter`）**必须**使用 `_` 前缀 + **camelCase** (e.g., `_i`, `_j`, `_k`, `_loopCounter`)。在 `FOR` 的括号内使用 `_varName(TYPE) = initialValue` 声明（例如 `FOR (_i(INT) = 0; _i < 10; _i++)`）。

#### **方法/函数名**:

- **前端公共方法** (`METHOD_PUB`): **PascalCase** (e.g., `ProcessData`, `ValidateForm`, `ReloadList`)
- **前端/后端内部方法** (`METHOD`): **camelCase** (e.g., `loadData`, `loadNotesFromServer`,`validateBackendInput`)
- **后端服务** (`SERVICE`): **PascalCase** (e.g., `UserLogin`, `GetDocList`)
- **前端/后台管道(PIPE)函数**: (用于纯数据转换): `_` 前缀 + **camelCase** （e.g. `_formatCurrency`, `_formatDate`）

#### 事件名：

**事件** (`<Component>.@click`): 事件名称都采用小驼峰命名法 (如 `@click`, @`init`, @`tick` , @`keyDown`)。

#### **方法/函数的入参:**

- 所有类型的方法/函数的**传入参数名均使用 camelCase (小驼峰) 命名法，无 `_` (下划线) 前缀**。
- 示例: `METHOD myMethod(userId(INT), configData({}))`，参数为 `userId`, `configData`。
- 示例: `PIPE _formatDate(dateValue(TIMESTAMP), formatString(STRING))`。
- **注意**: 当在方法内部引用这些传入参数时，直接使用其定义的名称 (e.g., `userId`, `configData`)。

#### 表与字段

* 所有表名大驼峰，包括Database中的Table与ServiceDomain中的VirtualTable
* 所有字段名小驼峰

#### 其他

- **公共事件定义** (`EVENT @eventName`): **camelCase** (e.g., `itemSelected`, `formSubmitted`)。

## 组件

### 组件实例创建

#### 创建位置

| 适用文件 | 定义段落        | 核心用途                   |
| -------- | --------------- | -------------------------- |
| vx,sc,cp | # Frontend Tree | 前端UI布局与功能性组件声明 |
| vs       | # Backend Tree  | 后端组件声明               |

#### 组件定义格式

```vl
<组件类-组件名称 "组件ID"> 功能属性1:值1 功能属性2:值2 StyleClass:样式类 覆盖CSS样式1:值1...
```

##### 组成要素

| 要素                       | 说明                                          | 命名规则   | 示例                                  | 注意事项                                                     |
| -------------------------- | --------------------------------------------- | ---------- | ------------------------------------- | ------------------------------------------------------------ |
| 组件类                     | 系统预定义的组件类型                          | 固定       | `Button`、`Text`、`Input`       | 不可修改，由系统定义                                         |
| 组件名称                   | 开发者自定义的描述性名称，反映组件用途        | PascalCase | `SubmitButton`、`UserStatus`      | 必须有意义，便于理解                                         |
| 组件ID                     | 组件在文件内的唯一标识符                      | camelCase  | `"submitBtn"`、`"userStatus"`     | 可选，仅在需要引用时指定，**纯静态字符串不支持表达式** |
| 功能属性                   | 组件文档中定义的属性                          | -          | `value`、`disabled`               | 严格参考组件文档，禁止自己发明属性                           |
| StyleClass  (仅前端组件)   | 组件预置样式类，字符串，支持表达式            | PascalCase | `"ButtonPrimary"`、"`TextTitle1"` | 必须在当前项目的Theme文件中预定义                            |
| 覆盖CSS样式 （仅前端组件） | 标准CSS属性，可覆盖StyleClass中定义的默认样式 | -          | `color`、`font-size`              | 如StyleClass中预置样式已满足需求，则无需定义                 |

**关键区分：**

* **组件名称** vs **组件ID**：
  * 组件名称是组件类型的描述性标识，用于定义和引用时的类型匹配
  * 组件ID是组件实例的唯一标识符，仅用于在同一文件内区分不同实例
  * 引用时必须使用 `<组件类-组件名称 "组件ID">`，不能用ID替换组件名称

##### ✅ 正确示例

```vl
<Button-Submit "submitButton"> value:"Submit" disabled:(!$canSubmit) StyleClass:"ButtonSubmit"
<Text-Welcome> value:"Hello" StyleClass:"Caption"
<Image-Logo "logo"> sourceUri:$logoUrl alt:"Company Logo" StyleClass:"Logo" height:"40px" width:"auto"
<Text-UserStatus> value:($isLoggedIn ? "Online" : "Offline")
```

##### 错误1：组件定义换行

```vl
❌ <Section-DynamicFormFields>
     value:$formData[_field.name]
     error:$formErrors[_field.name]

✅ <Section-DynamicFormFields> value:$formData[_field.name] error:$formErrors[_field.name]
```

### 组件树的结构

#### 根组件

根组件是一个特殊的组件，其作为整个文件的起始标记添加在文件开头，除此之外，其使用规则和普通组件一致：

* 前端根组件（`<App>`,`<Section>`,`<Component>`）同时带有布局容器功能，所有 `# Frontend Tree`中的组件，都添加在这个容器下。其布局功能同一个 `Col`容器，可添加样式属性，比如：`<Section-ProductCard "root"> width:"320px" min-height:"400px" background-color:"#ffffff"`
* 前端根组件，可添加 `@init()`等通用布局容器事件，比如 `<App-MyApp “root”>@init()`,`<Section-MySection "root">@init()`
* `<ServiceDomain>`根组件，暂时没有属性和方法，仅作为文件起始声明

#### 组件创建顺序

前端组件树中，组件创建顺序如下：

1. 功能性组件（无UI），比如FrontendApi, Trigger, WindowEventListener, ClientUserCenter等
2. UI与容器组件

后台组件树中，组件创建顺序如下：

1. 功能性组件，如ServerApi等
2. 后台数据组件，如VirtualTable

#### 组件的父子关系

当任何一个组件B是另一个组件A的子组件时，请将B添加在A之下，并在A的基础上额外增加一级缩进。在VL中，父子关系存在于以下场景中：

**允许添加子组件的情况**

* 所有的容器组件（UI容器、逻辑容器），可以有其他前端组件（容器、基础UI组件，扩展UI组件等）作为子组件
* 无UI功能性组件（FrontendApi, Trigger等）仅能作为根组件的直接子组件
* 任何带有UI的组件（UI容器，UI组件），都可以添加挂件来拓展其自身功能（StateStyle, Animation, UseDrag等）

**严格限制或禁止添加子组件的情况**

* 无UI功能性组件，严禁添加任何子组件
* 非容器类UI组件（基础/扩展UI组件）禁止添加除了挂件外的其他任何子组件
* 模块组件（Section/Component）其性质和扩展UI组件类似，禁止添加除了挂件外的任何其他子组件

### 组件的后续使用与访问

#### 组件的使用场景

组件在组件树中定义后，可在后续事件/方法/函数/表达式中使用。生发严格规定如下：

| 用法                                               | 事件 | 方法 | PIPE函数/表达式 |
| -------------------------------------------------- | ---- | ---- | --------------- |
| 监听组件的事件，如 `.@init()`                    | ✅   | ❌   | ❌              |
| 调用组件的方法，如 `.scrollToBottom()`           | ✅   | ✅   | ❌              |
| 访问组件的只读属性，如 `_position = .offsetLeft` | ✅   | ✅   | ✅              |

#### 组件的正确访问方式

请使用 `<组件类-组件名 "组件ID">`的方式引用，注意，组件类、组件名和组件ID请严格和组件树中的定义保持一致。**切勿混淆组件名与组件ID。**

```
# Frontend Tree
<Button-Next "nextButton"> disabled:$status

# Frontend Event Handlers
<Button-Next "nextButton">.@click() // 尖括号内内容严格与组件树中保持一致
```

#### 错误的访问方式(严格避免)

**错误1：混淆组件名称与组件ID**

```vl
❌ 错误用法：
# Frontend Tree
<Button-BackButton "backToProjects"> value:"← Project List"

# Frontend Event Handlers
<Button-BackToProjects "backToProjects">.@click()
// 错误：用ID"backToProjects"替换了组件名称"BackButton"

✅ 正确用法：
# Frontend Tree
<Button-BackButton "backToProjects"> value:"← Project List"

# Frontend Event Handlers
<Button-BackButton "backToProjects">.@click()
// 正确：保持组件类和组件名称一致
```

**错误2：直接将组件本身赋值给一个变量**

```
❌ 错误用法：
_currentObj = <Block-ScrollItem "scroller"> // VL中的组件可以直接访问其只读属性，无需通过类似document.getElementById()的方法先将对象暂存至一个局部变量，然后后续再访问。
_distance = _currentObj.scrollTop
✅ 正确用法：
_distance = <Block-ScrollItem "scroller">.scrollTop
```

**错误3：访问组件的样式（不存在.style的访问方式）**

```
❌ 错误用法：
-_color = <Block-Container "box">.style.color //组件的样式不能在事件或方法中被访问
-<Block-Container "box">.style.color = "red" //组件的样式不能在事件或方法中修改

✅ 正确用法：
//在组件树中定义变量绑定
<Block-Container "box"> color:"$color"
//在事件或方法中修改变量
-$color = "red"
```

```
❌ 错误用法：：通过display属性来控制组件的显隐
-_userSubMenu = <Col-UserSubMenu "userSubMenu"> // 错误1：不能直接将组件实例赋值给一个变量
-_currentDisplay = _userSubMenu.style.display //错误2：不能访问.style属性
-IF _currentDisplay == "none"
--_userSubMenu.style.display = "block" //错误3：尝试修改组件的display样式，VL中的所有组件均没有display样式，此样式固化在组件定义中不能修改

✅ 正确用法：通过组件的通用show属性来控制其显隐
//在组件树中定义变量绑定
<Col-UserSubMenu "userSubMenu"> show:"$show"
//在事件或方法中修改变量
-IF $show == false
-- $show = true
```

#### 先定义后使用原则

除了系统方法类组件，其他所有组件，都需要先在组件树中定义，才可以在后续方法/函数中引用。

请特别注意以下功能性无UI的组件，也需要先定义：`Trigger`，`FrontendApi`，`WindowEventListener`，`ClientUserCenter`

#### 系统方法类组件

系统方法类组件，是一种特殊的组件，其全局只有一个实例，是对系统方法的便捷访问方式。因此，其不需要在组件树中定义，可直接使用，比如：

`<ClientUtils>.consoleLog(123)`

### 组件的属性

#### 属性顺序

**请严格按以下顺序指定组件属性：**

* 功能性属性：如value、type、disabled等, 请严格参照组件文档
* StyleClass：当前组件的预置样式类，请严格参照当前项目的 `.vth`文件定义
* 覆盖CSS样式属性：额外定义的CSS样式，可覆盖StyleClass中预置样式类中的样式

#### 只读与非只读属性

* **非只读属性**定义了组件的行为、数据、逻辑、核心特性和非视觉状态。它们决定了组件"是什么"以及"如何工作"。
* **只读属性**主要为dom元素的只读属性，比如offsetWidth等。这些属性不需要在 `# Frontend Tree`中定义，可以后续直接在方法/函数中访问。
* 无论是只读还是非只读属性，请**严格参照组件文档**，不允许自行发明任何属性。

#### 属性读写规则（单向数据流）

VL 采用 **单向数据流(Unidirectional Data Flow)** 架构，**不存在v-model语法糖**。

##### 非只读属性读写规范 (Attribute Mutability)

1. **禁止**在任何方法 / 事件 / 函数/ 表达式 中**直接读取或修改组件非只读属性**（形如 `Button.color` 或 `Modal.show = false`）。
2. 若需要动态控制属性，请遵循 **"变量中转"** 模式：
   - 先在属性上 **绑定(bind)** 一个变量（如 `show:$isModalVisible`）。
   - 在逻辑中 **仅修改该变量**（`$isModalVisible = false`），由响应式绑定驱动组件刷新。
3. 设计初衷
   - 保持 **严格单向数据流**，避免难以追踪的副作用。
   - 提升代码可读性：所有可变状态集中体现在变量命名上，一目了然。

##### 只读属性读写规范

只读属性，可在方法/函数中读取（不能写），不会破坏单向数据流：

```
# Frontend Event Handlers

<Button-CheckSize "checkButton">.@click()
// ✅ 允许：读取尺寸信息
-_buttonWidth(FLOAT) = <Button-Submit "submitButton">.offsetWidth
-_buttonHeight(FLOAT) = <Button-Submit "submitButton">.offsetHeight
-_rect({}) = <Block-MainContainer "mainContainer">.getBoundingClientRect()

// ✅ 允许：读取位置信息
-_scrollTop(FLOAT) = <Block-Content "docContent">.scrollTop
-_offsetLeft(FLOAT) = <Image-Logo "logo">.offsetLeft
```

## 变量

### 基础类型

- **STRING**: 文本字符串，如 "Hello"。字符串值通常用双引号 `"` 包裹。当字符串值内部需要包含双引号时，可以使用单引号 `'` 包裹。**VL中严禁使用任何 `\`转义符。**
- **INT**: 整数，如 42
- **FLOAT**: 浮点数，如 3.14
- **BOOL**: 布尔值，true或false
- **TIMESTAMP**: 内部存储标准时间字符串格式，比如 2024-12-12 11:11:11.342，定义时可以传没有毫秒的字符串，比如2024-12-12 11:11:11。作为"时间货币"可用于所有时间相关场景。（详见时间类型详细说明章节）

### 复合类型

- **数组**: `[元素类型]`，如 `[INT]`, `[STRING]`, `[{id:INT,name:STRING}]`。不确定内部结构时，可以用 `[]`。
- **对象**: `{字段:类型}`，如 `{id:INT,name:STRING,items:[{id:INT}]}`。不确定内部结构时，可以用 `{}`。
  - **补充说明**: 当一个对象在定义时字段不确定，或字段将在运行时动态添加时，可以初始化为空对象 `{}` (例如 `_seen({}) = {}`)。此时，VL 会将其推断为一个基础对象类型。后续可以向其动态添加属性。例如：`_myDynamicObject({}) = {}`，然后 `_myDynamicObject.newProp = "value"` 或 `_myDynamicObject["anotherProp"] = 123`。
- **JSON**: 可以先定义JSON类型，再使用，如先定义 `_myJsonVar(JSON) = null`，后续在方法/事件中，可以再赋值为 `_myJsonVar(JSON) = _apiResult`。JSON 类型通常用于那些结构在编译时**不完全确定**或**可变**的数据。注意：如果某个数据类型是一个确定的对象或数组，只是不知道内部的具体结构，请更明确得将其定义为 `[]`或 `{}`, 而不是简单的归于JSON。
- **复合类型初始化**必须包含所有必需字段，或使用合法的空结构（如空对象 `{}` 或空数组 `[]`）；**JSON 类型仅允许初始化为 `null`** 作为"未知结构、待后填充"的占位符。

```vl
// JSON类型 - 用于与外部API交互或结构完全不确定的数据
_apiResponse(JSON) = null
_flexibleConfig(JSON) = null

// 动态对象类型 - 用于已知会动态添加属性的场景
_lookup({}) = {}
_cache({}) = {}
```

### 时间类型

#### 时间变量赋值

VL中的TIMESTAMP类型采用统一的字符串格式作为"时间货币"，如 `2024-12-12 11:11:11.342` 或 `2024-12-12 11:11:11`，可省略毫秒部分。在对时间类型的全局或局部变量进行"="赋值时，可接收以下输入类型：

* **系统变量**：如 `$serverDate = SYSENV.currentTime`。
* **Unix 时间戳**：毫秒级；如需使用秒级时间戳，请使用 `setUnixS()`方法
* **字符串**（五种格式，全部大小写敏感）：

  * `"YYYY-MM-DD HH:mm:ss"`
  * `"YYYY-MM-DD HH:mm:ss.SSS"`
  * `"YYYY-MM-DD"`
  * `"YYYY-MM-DDTHH:mm:ssZ"`
  * `"YYYY-MM-DDTHH:mm:ss.SSSZ"`
* **初始化推荐格式**：

  - 定义时优先使用完整格式：`$createTime(TIMESTAMP) = "2024-12-12 11:11:11.342"`
  - 系统变量 `SYSENV.currentTime` 返回格式为标准时间字符串（含毫秒）

#### 时间变量的使用

在大多数场景中可直接使用TIMESTAMP变量，无需显式转换

* 所有时间相关变量的赋值：`$eventTime(TIMESTAMP) = "2024-12-12 11:11:11"`
* 参数传递：`processEvent(eventTime)` 其中eventTime为TIMESTAMP类型
* 数据库时间比较：`[["createTime", "gt", $startTime]]`

**示例**:

```vl
$eventTime(TIMESTAMP) = "2024-12-12 15:30:00"
$displayTime(STRING) = $eventTime.format("YYYY-MM-DD HH:mm")
<Text-EventTime> value:($eventTime.format("MM/DD HH:mm"))
```

#### 时间变量的方法与函数

**Immutable方法:**

* **格式化输出**: 使用 `.format(输出格式)` 方法进行格式化显示，输出格式包括：YYYY (四位数年份，如2024), YY (两位数年份，如24), M (一位数月份，如1-12), MM (两位数月份，如01-12), MMM (短月份名称，如Jan, Feb), MMMM (完整月份名称，如January), D (一位数日期，如1-31), DD (两位数日期，如01-31), d (一周中的第几天，如0-6), H (24小时制一位数小时，如0-23), HH (24小时制两位数小时，如00-23), h (12小时制一位数小时，如1-12), hh (12小时制两位数小时，如01-12), m (一位数分钟，如0-59), mm (两位数分钟，如00-59), s (一位数秒，如0-59), ss (两位数秒，如00-59), SSS (三位数毫秒，如000-999), A (12小时制上午/下午，如AM/PM), a (12小时制上午/下午，如am/pm)
* **时间戳获取**: 使用 `.unixS()` 和 `.unixMS()` 方法

**Mutable函数：**

* `variable.setUnixS(秒级时间戳)`
* `variable.setUnixMS(毫秒级时间戳)`
* `variable.setCustomFormat("时间字符串", "对应的格式字符串")`

**禁止的操作**:

* **禁止直接调用JavaScript Date API**: 不支持直接调用 `new Date(...)`, `.getTime()`, `.getFullYear()`, `.getMonth()`, `.getDate()` 等JS原生Date方法

### 变量定义

#### 前端全局变量定义 (`# Frontend Global Vars`)

前端全局变量在文件级别的前端环境可访问，使用 `$` 前缀：

```
$变量名(类型) = 初始值
```

示例：

```vl
$userName(STRING) = ""
$userCount(INT) = 0
$isLoggedIn(BOOL) = false
$userData({id:INT,name:STRING,age:INT}) = {id:0,name:"",age:0}
$items([{id:INT,title:STRING}]) = []
$genericArray([{}]) = [{}]
```

#### 派生变量定义 (`# Frontend Derived Vars`)

派生变量是从其他变量自动计算得出的只读变量：

```vl
# Frontend Global Vars
$firstName(STRING) = "John"
$lastName(STRING) = "Doe"
$isLoading(BOOL) = false
$cartItems([{name:STRING,price:FLOAT,quantity:INT}]) = []

# Frontend Derived Vars
$itemCount(INT) = $cartItems.reduce((acc, item) => acc + item.quantity, 0)
$canSubmit(BOOL) = ($firstName != "" && !$isLoading)
$userSummary(STRING) = ("User: " + ($firstName + " " + $lastName) + " (Status: " + ($isLoading ? "Loading" : "Ready") + ")")
$loadingStatus(STRING) = $isLoading._mapLoading()
```

**重要规则：**

- 只能包含纯计算，不能调用METHOD/SERVICE等动作，但可以使用PIPE函数与变量的immutable函数
- 派生变量是只读的，不能在代码中赋值
- 重要：**派生变量务必定义类型**

#### 局部变量定义

##### 方法/函数内局部变量

局部变量在方法内部使用，使用 `_` 前缀。它们**必须**显式声明类型 (例如, `_varName(TYPE) = ...`) 或通过初始化空结构进行类型推断 (例如, `_varName({}) = {}`, `_varName([]) = []`)。**无** `let` 关键字：

```
_变量名(类型) = 值
// 或
_变量名({}) = {}
_变量名([]) = []
```

示例：

```vl
METHOD processData()
-_result({type:STRING}) = {}
-_count(INT) = 0
-_userList([{id:INT,name:STRING}]) = []
-_lookupTable({}) = {}
-_genericItems([{}]) = [{}]
```

- 局部变量和全局变量一样，需要在初始化时声明类型或通过空结构进行类型推断。（循环控制变量是此规则的一个特例，详见循环章节）
- 局部变量声明时**切勿漏掉等号与初始值**，否则局部变量的定义会被勿认为是公共方法的调用：

```
METHOD processData()
-_condition([]) = [] //定义一个名为_condition的局部变量
-_condition([]) // 调用一个名为_condition的公共方法
```

##### 循环容器局部变量

在For, Tree等循环容器组件属性中，可以声明当前循环容器的局部变量。比如：

```
<For-UserList> sourceArray:$users,loopVar:[_item0,_index0] // _item0, _index0为当前结构循环的循环变量和循环index，属于组件树中声明的局部变量，请使用_前缀
```

#### 系统变量 (`SYSENV`, `WINDOW`)

系统变量可以直接使用，用来获取当前系统的环境信息。

| 变量名称           | 适用范围               | 内部属性                                                                                                                                                                                                                                                                                                                                    |
| :----------------- | :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| SYSENV.currentUser | 前端和后台             | **isLogin**: BOOL (用户是否登录) **userId**: STRING (用户ID) **userInfo**: {id:INT, username:STRING, avatar:STRING, deleted:INT, deptId:INT, disableStatus:INT, email:STRING, lastTimeLogin:TIMESTAMP, fullName:STRING, nickname:STRING, phoneNumber:STRING} (当前用户信息对象) **tenantId**: INT (租户ID，可能为0) |
| SYSENV.currentTime | 前端和后台             | 无。可直接赋值给一个时间变量，如 `$currentTime(TIMESTAMP) = SYSENV.currentTime`                                                                                                                                                                                                                                                           |
| SYSENV.requestInfo | 仅后台                 | **ip**: STRING (请求客户端IP) **userAgent**: STRING (请求客户端UA字符串) **headerInfo**: {} (当前请求的header信息) **cookie**: {} (当前请求的cookie)                                                                                                                                                                |
| WINDOW             | 仅前端（表达式和事件） | 提供对浏览器 `window` 对象属性的只读访问。与组件配合使用，用于响应窗口事件（如 `resize`, `scroll`）。**禁止调用** `WINDOW` 对象的方法。可访问的属性包括：`innerWidth`, `innerHeight`, `outerWidth`, `outerHeight`, `devicePixelRatio`, `scrollX`, `scrollY` 等。                                                |
| --themeTokenName   | 前端                   | 所有在 Theme.vth 中定义的 Token 变量，可在前端代码中直接引用，比如 ` font-size:--fontSizeLg color:--colorTextDefault`                                                                                                                                                                                                                     |

### 变量赋值与修改

#### 变量赋值

变量赋值使用等号 `=`，不需要再声明类型：

```
$变量名 = 新值
_变量名 = 新值
```

* `=`操作遵循js规则，即当新值为简单值（STRING，INT，FLOAT，BOOL）时，赋值为这个值本身；当新值为复杂数据结构时（数组，对象，JSON）赋值为这个数据结构的引用。

#### 复杂数据结构"原地修改"的支持

VL中对复杂数据结构（对象、数组、json）**不要求**react/vue框架中的**数据不可变性（immutability）**，框架会自动处理原地修改后的数据更新与性能优化问题。VL中**支持并推荐直接对复杂结构中的某一部分进行修改**：

```
# Frontend Global Vars
$users([{name:STRING}]) = []

# Frontend Tree
-<For-UserList> sourceArray:$users loopVar:[_item0,_index0]
--<Text-Name> value:_item0.name

# Frontend Event Handlers
<Button-Change "changeButton">.@click()
$users[0].name = "adam" // 直接修改数组中的某个值，其绑定的UI会自动改变，无需遵守immutability，创建一个新的数组然后再整体赋值回去。
$users.push("alice") // 通过mutable方法原地修改数组，其绑定的UI也会自动更新
```

#### 变量的mutable方法

在方法与事件中，可以调用变量的 **mutable** 方法(会改变原变量) 。这些操作语句遵循其所在代码块的缩进规则（通常至少缩进一级 `-`）。

**重要：Mutable方法仅可在方法中直接调用，任何表达式中（包括属性绑定、`conditions`、`IF/FOR` 的条件/循环体等）仅能使用 immutable函数。**

| **变量类型** | **允许在方法中使用的 Mutable Methods**                                              |
| :----------------- | :---------------------------------------------------------------------------------------- |
| 数组               | `push` ,`pop` ,`shift`, `unshift` ,`splice`,  `sort` ,`reverse` ,`delete` |
| 对象               | `Object.assign`, `delete`                                                             |
| 时间               | `setUnixS`, `setUnixMS` ,`setCustomFormat`                                          |

> **⚠️ 使用限制**：Mutable操作只能作为独立语句出现在方法体中，不能在表达式、条件判断或链式调用中使用。
> 错误示例：`_result = items.push(newItem)`
> 正确示例：
>
> ```vl
> items.push(newItem)
> _result = items
> ```

**示例 (在方法内):**

```vl
METHOD manageList(items([STRING]), newItem(STRING)); RETURN {updatedList:[STRING], success:BOOL}
-_listCopy([STRING]) = items.slice()
-_listCopy.push(newItem)
-_listCopy.splice(0, 1)
-_listCopy.sort()
-RETURN {updatedList:_listCopy, success:true}

METHOD updateTimestamp(timeVar(TIMESTAMP)); RETURN {newTime:TIMESTAMP, success:BOOL}
-_localTime(TIMESTAMP) = timeVar
-_localTime.setUnixS(1700000000)
-RETURN {newTime:_localTime, success:true}
```

#### 变量的内置immutable函数/属性

变量的内置immutable函数可以在表达式中调用，类型包括：

| 分类           | immutable 函数                                                                                                                                                                  |
| :------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 数组           | `map()`, `filter()`, `reduce()`, `indexOf()`, `includes()`, `slice()`, `concat()`, `join()`,`length` (属性)                                                   |
| 字符串         | `split()`,  `trim()`, `toLowerCase()`, `toUpperCase()`, `replace()`, `replaceAll()`, `substring()`, `slice()`, `includes()`, `indexOf()`, `length` (属性) |
| 数字           | `toFixed()`, `toPrecision()`, `toExponential()`                                                                                                                           |
| 对象           | `Object.keys()`, `Object.values()`, `Object.entries()`                                                                                                                    |
| 时间           | `unixS()`、`unixMS()`、`format()`                                                                                                                                         |
| 类型检查       | `typeof`                                                                                                                                                                      |
| 数学           | `Math.random()`、`Math.floor()`、`Math.ceil()`、`Math.round()`、`Math.max()`、`Math.min()`、`Math.abs()`、`Math.pow()`                                          |
| JSON处理       | `JSON.parse()`、`JSON.stringify()`                                                                                                                                          |
| 正则处理       | `match()`, `test()`                                                                                                                                                         |
| 类型转换与判断 | `String()`,` Number()`, `parseInt()`,`parseFloat()`,`Boolean()`, `isNaN()`, `isFinite()`                                                                          |

* 变量内置函数可以直接调用，不需要预先定义。
* 调用时，请直接使用函数名，**不添加 `_`前缀：**
  * 正确 (直接使用)：`_num.toFixed()`
  * 错误 (与PIPE函数混淆，添加 `_`)：`_num._toFixed()`

#### 禁止使用的JS方法：

* `toString()`: 请用 `String()`代替，适用性更广

#### 变量方法中"回调函数参数"的使用规则

##### 硬规则（Must / Must Not）

* **MUST**：在map / filter / reduce / some / every / sort 的回调函数参数，**必须使用箭头函数，切函数体必须是单一表达式（concise body）。**
* **MUST**：**回调必须纯同步、无副作用**（不得修改外部/上层变量、不得调用异步的 METHOD/组件方法
* **MUST NOT**：在回调中使用带副作用的语句（如 acc[k]=...、push/splice 等写操作
* **MUST NOT**：不得书写 return 语句块。

✅ **正确（纯表达式）**：

```vl
arr.reduce((acc, x) => acc + x, 0)
arr.map(x => ({ id: x.id, name: x.name?.trim() }))
params.reduce((acc, p) => ({ ...acc, [p.name]: p.def ?? "" }), {})
```

❌ **错误（语句块 + 副作用）**：

```vl
arr.reduce((acc, p) => { acc[p.name] = p.def || ""; return acc; }, {})
JSON.parse(...)._reduce((acc, p) => { ... }, {})
```

## Database表与虚拟表字段类型

后台Database表与虚拟表支持以下字段类型：STRING，INT，FLOAT，BOOL，TIMESTAMP，JSON，VEC

注意：后台表的字段类型与变量类型有以下区别：

* 后台没有对象与数组类型的字段，复杂结构请统一使用JSON类型
* 后台额外有VEC向量类型的字段，用于向量搜索，VL中暂时不支持VEC类型的变量。

除上述两个区别外，其他的字段类型的数据定义与变量的数据类型完全一致。

### 向量字段的使用

向量字段，用于向量搜索，在VL中，只需要定义一个向量字段的vecSource（向量化数据来源字段），即会在表的数据插入/更新时，自动对来源字段进行向量化处理。

#### 向量字段的定义

**1、在虚拟表中定义向量字段**

```
<ServiceDomainRoot-Root>
-<VirtualTable-Documents> "docTable" mockData:[{...}]
--<Field-title> type:STRING
--<Field-content> type:STRING
--<Field-contentVec> type:VEC vecSource:["title","content"] // 向量字段的数据来源是title和content，其数据会自动对上述两个字段的值进行向量化
```

* 大多数情况下，一个虚拟表只需要一个向量字段。请将所有可能参与内容搜索的字段，添加为向量字段的vecSource，而不是每个内容字段对应一个向量字段。

**2、在Database实体表中定义向量字段**

```
<Table-documents> data:[{"_id":1,"title":"VL框架入门指南","content":"VL是一种创新的可视化编程语言，支持前后端开发...","_user":"1","_create":"2024-01-15 09:30:00","_update":"2024-01-15 09:30:00"}] // 测试数据中不指定contentVec字段，这个字段是系统自动生成的
-<Field-_id> type:INT
-<Field-title> type:STRING
-<Field-content> type:STRING
-<Field-contentVec> type:VEC vecSource:["title","content"]
-其他字段
```

向量字段，与普通字段的绑定有以下区别：

* 向量字段的绑定不支持表达式，只能一对一绑定
* 虚拟表与实体表的向量字段vecSource必须严格一致。比如，虚拟表的virtualVec字段，sourceVec为virtualA、virtualA两个虚拟字段，并绑定了实体表的realVec字段；realVec的sourceVec字段为realA，realB。那么realA、realB与virtualA、virtualB必须严格对应。即当虚拟表的一个向量字段与实体表的向量字段绑定时，两者的向量化源也必须是一一绑定的。

#### 向量搜索

向量搜索通过 `select` 方法的 `conditions`（筛选）和 `orderBy`（排序）参数实现：

**向量排序（orderBy）：**

* 格式：`[["向量字段名","搜索文本"],...]`
* 自动按相似度从高到低排序（向量距离从小到大）
* 可与普通字段排序混合：`[["contentVec","AI Tech"],["_create","desc"]]`

**向量筛选（conditions）：**

* 格式：`["向量字段名","l2str","搜索文本",最大距离]`
* 最大距离即距离搜索文本的最大距离，最大距离的值小于等于1
* 可与普通筛选条件组合：`[["status","eq","published"],["contentVec","l2str,"关键词",0.4]]`
* 支持在OR条件中使用：`[["OR",["titleVec","l2str","关键词",0.3],["contentVec","l2str","关键词",0.3]]]`

**示例：**

```vl
-<VirtualTable-Documents "docTable">.select([["status","eq","published"],["contentVec","l2str",keyword,0.4]],[["contentVec",keyword],["_create","desc"]],[_offset,pageSize],null) -> _result
```

**注意事项：**

* 向量字段在 `insert`/`update` 时不需要手动赋值，系统根据 `vecSource` 字段自动生成
* 向量字段不支持 `eq`、`contains` 等普通操作符，仅支持 `l2str` 筛选和相似度排序
* 搜索文本会被系统自动向量化后进行匹配

## 逻辑定义

### 事件、方法、函数与表达式的概念区分

#### 核心对比表

| 类型             | 定义                                     | 副作用 | 调用位置                                         | 内部可使用         | 典型用途                     |
| ---------------- | ---------------------------------------- | ------ | ------------------------------------------------ | ------------------ | ---------------------------- |
| **事件**   | 响应用户交互或系统状态变化的被动触发逻辑 | ✅ 有  | `# Frontend Event Handlers` 段落，监听组件事件 | 方法、函数、表达式 | 处理点击、输入、初始化等交互 |
| **方法**   | 可执行完整业务逻辑的主动调用单元         | ✅ 有  | 事件处理器、其他方法                             | 方法、函数、表达式 | 数据处理、服务调用、状态修改 |
| **函数**   | 纯数据转换的计算单元                     | ❌ 无  | 事件、方法、函数、表达式                         | 函数、表达式       | 格式化、验证、数组转换       |
| **表达式** | 返回单一值的计算式                       | ❌ 无  | 属性绑定、条件判断、派生变量                     |                    | UI 显示、条件控制、动态计算  |

#### 相互调用规则（严格遵守）

|                      | 调用事件 | 调用方法 | 使用函数 | 使用表达式 |
| -------------------- | -------- | -------- | -------- | ---------- |
| **在事件中**   | ❌       | ✅       | ✅       | ✅         |
| **在方法中**   | ❌       | ✅       | ✅       | ✅         |
| **在函数中**   | ❌       | ❌       | ✅       | ✅         |
| **在表达式中** | ❌       | ❌       | ✅       | ✅         |

#### 1. 事件 (Event)

**本质**：被动触发的交互响应入口

**特征**：

- 不能被主动调用，只能被监听
- 由用户操作或组件状态自动触发
- 独立定义在 `# Frontend Event Handlers` 段落

**使用场景**：

```vl
# Frontend Event Handlers

// ✅ 典型用法：处理按钮点击
<Button-Submit "submitBtn">.@click()
-validateForm() -> _validation
-IF _validation.success
--submitData()

// ✅ 典型用法：处理输入变化
<Input-Email "emailInput">.@change(newValue, oldValue)
-$email = newValue
-$isValid = newValue._isValidEmail()

// ❌ 错误：事件不能被调用
METHOD processData(); RETURN {success:BOOL}
-<Button-Submit "submitBtn">.@click()  // 错误！
```

#### 2. 方法 (Method)

**本质**：可重用的业务逻辑封装单元

**特征**：

- 可主动调用
- 可修改变量、调用服务、执行 I/O
- 必须返回对象格式 `{key:Type, ...}`

**使用场景**：

```vl
// ✅ 前端公共方法：供外部调用
METHOD_PUB ValidateInput(email(STRING)); RETURN {valid:BOOL, message:STRING}
-IF email == ""
--RETURN {valid:false, message:"Email cannot be empty"}
-IF !email.includes("@")
--RETURN {valid:false, message:"Invalid email format"}
-RETURN {valid:true, message:""}

// ✅ 内部方法：封装复用逻辑
METHOD loadUserData(userId(INT)); RETURN {success:BOOL, data:{}}
-<ServiceDomain-User "userService">.GetUserInfo(userId) -> _result
-IF !_result.success
--RETURN {success:false, data:{}}
-$userData = _result.data
-RETURN {success:true, data:_result.data}

// ✅ 服务方法：后端业务逻辑
SERVICE GetDocList(keyword(STRING)); RETURN {success:BOOL, data:[{}]}
-<VirtualTable-Documents "docTable">.select([["title","*contains",keyword]]) -> _result
-RETURN {success:true, data:_result.dataArray}

// ❌ 错误：方法不能在表达式中调用
<Text-Result> value:calculateTotal()  // 错误！需改用 PIPE
```

#### 3. 函数 (Function)

**本质**：纯数据转换的管道

**特征**：

- 无副作用（不修改外部状态）
- 仅用于表达式
- 必须用 `_` 前缀命名

**使用场景**：

```vl
// ✅ 管道函数定义
PIPE _formatPrice(price(FLOAT)); RETURN STRING
-RETURN ("¥" + price.toFixed(2))

PIPE _isValidEmail(email(STRING)); RETURN BOOL
-RETURN (email.includes("@") && email.includes("."))

// ✅ 在表达式中调用
<Text-Price> value:$price._formatPrice()
<If-ValidEmail> conditions:$email._isValidEmail()

# Frontend Derived Vars
$formattedTotal(STRING) = $totalPrice._formatPrice()

// ✅ 变量内置函数（无需 _ 前缀）
-_names([STRING]) = $users.map((u) => u.name)
-_total(FLOAT) = $prices.reduce((sum, p) => sum + p, 0)
-_formatted(STRING) = $timestamp.format("YYYY-MM-DD")

// ❌ 错误：函数不能产生副作用
PIPE _saveAndFormat(value(STRING)); RETURN STRING
-$savedValue = value  // 错误！修改了全局变量
-RETURN value.trim()
```

#### 4. 表达式 (Expression)

**本质**：返回单一值的计算式

**特征**：

- 无副作用
- 不能调用 METHOD
- 支持运算符、函数、三元运算

**使用场景**：

```vl
// ✅ 属性绑定
<Text-FullName> value:($firstName + " " + $lastName)
<Button-Submit> disabled:(!($formValid && $dataReady))
<Text-Status> value:($age >= 18 ? "Adult" : "Minor")

// ✅ 条件容器
<If-HasItems> conditions:($items.length > 0)
<If-CanSubmit> conditions:($email._isValidEmail() && $password.length >= 6)

// ✅ 派生变量
# Frontend Derived Vars
$totalPrice(FLOAT) = $items.reduce((sum, item) => sum + item.price, 0)
$displayName(STRING) = ($userName != "" ? $userName : "Guest")
$canCheckout(BOOL) = ($cartItems.length > 0 && $totalPrice > 0)

// ❌ 错误：表达式不能调用 METHOD
<Text-Result> value:calculateTotal()  // 错误！
<If-Check> conditions:validateForm()  // 错误！

// ❌ 错误：表达式不能使用 mutable 方法
<Text-Count> value:$list.push(5)  // 错误！
# Frontend Derived Vars
$sorted([{}]) = $items.sort((a, b) => a.price - b.price)  // 错误！
```

### 方法

#### 方法的定义位置与格式

| 方法类型         | 适用文件   | 定义段落                    | 定义前缀   | 方法名格式 |
| ---------------- | ---------- | --------------------------- | ---------- | ---------- |
| 前端内部方法     | vx、sc、cp | # Frontend Internal Methods | METHOD     | 小驼峰     |
| 前端模块公共方法 | sc、cp     | # Frontend Public Methods   | METHOD_PUB | 大驼峰     |
| 服务             | vs         | # Services                  | SERVICE    | 大驼峰     |
| 后端内部方法     | vs         | # Backend Internal Methods  | METHOD     | 小驼峰     |

**定义格式**

方法的定义行位于顶层，无缩进。方法体内的所有代码行都需要至少一级缩进 (`-`)。

```
<定义前缀> <方法名>(param1(Type1),param2(Type2),...);RETURN {returnVal1:Type1,returnVal2:Type2,...}
-方法体
```

#### 方法参数定义

方法参数使用camelCase，并需要指定类型，比如: `rawEmail(STRING), tags([FLOAT])`

#### 方法RETURN结构

所有方法，**`RETURN` 的结构必须是一个对象 `{}`**，即使只有一个返回值。

**为了配合系统默认错误处理机制，建议返回对象中始终包含** **success:BOOL** **字段，以及可选的** **message:STRING** **字段。比如：**

```vl
METHOD calculateTotal(prices([FLOAT]),discount(FLOAT));RETURN {total:FLOAT,discounted:FLOAT,success:BOOL}
-_sum(FLOAT) = 0
-FOR (_price,_index0) IN prices
--_sum = _sum + _price
-_discountedValue(FLOAT) = _sum * (1 - discount)
-RETURN {total:_sum,discounted:_discountedValue,success:true}
```

#### 方法的调用

**调用方式**

* 文件内部自定义方法的调用：可直接使用 `<方法名>(参数)`，前端文件内部可以调用前端公共方法与内部方法，ServiceDomain文件内部可调用服务和后台内部方法；
* 系统/组件方法的调用：使用 `<组件类-组件名 "组件ID">.方法名(参数)`
* 变量方法的调用：使用 `<变量名>.方法名(参数)`

**方法返回值的处理**

使用 `-> variableName` 将方法返回的数据存储到指定的变量中。`variableName` 可以是一个预先声明的局部变量 (以 `_` 开头) 或一个预先声明的全局变量 (以 `$` 开头，取决于当前环境)。当没有返回值或不需要接收返回值时，可以省略 `->` 。

```vl
-methodName(参数值1,参数值2,...) -> _apiResponse // 将值传给一个预先定义，或预先未定义过的局部变量。如果预先未定义，系统会自动创建这个局部变量
-<ServiceDomain-DomainName>.ServiceName(参数值1,参数2,...) -> $globalStatus // 将值直接传给全局变量，注意，暂时不支持传给全局变量的某个子字段，比如 $globalStatus.type是不允许的
-<ClientUtils>.delay(1500) //方法无返回值
```

**最佳实践**：推荐优先将方法/服务调用结果存储到局部变量 (`_variableName`) 中，以保持清晰的作用域和数据流。仅在确实需要直接更新一个已存在的全局状态时，才考虑使用全局变量 (`$variableName`) 作为接收方。

**示例:**

```vl
$isUserCreated(BOOL) = false

METHOD process(); RETURN {success:BOOL}
-_validationResult({})
-_creationDetails({}) = {}
-calculateTotal($prices, 0.1) -> _totalResult
-_finalTotal(FLOAT) = _totalResult.discounted
-<Section-MySection "mySection">.ValidateInput($email, $password) -> _validationResult
-IF _validationResult.success
--createUser($userData) -> _creationDetails
--$isUserCreated = true
--@userCreated(_creationDetails.userId)
-RETURN {success:true}
```

#### 内部方法的使用边界

在前端和后台的开发中，内部方法仅用作**可重用逻辑**的定义，其使用场景有严格的规范：

* 当一段逻辑仅在一个事件方法/服务/公共方里使用到时，请直接在这个事件方法/服务/公共方里编写该逻辑。禁止先定义一个内部方法，然后在这个事件方法/服务/公共方里调用该内部方法；
* 当一端逻辑在2个或2个以上的事件方法/服务/公共方法中使用到时，必须将这个逻辑封装为一个内部方法，避免重复代码

### 函数

#### 管道函数定义的文件与段落

VL中，可在代码文件中自定义数据转换管道函数：

| 函数类型     | 适用文件   | 定义段落                  |
| ------------ | ---------- | ------------------------- |
| 前端管道函数 | vx、sc、cp | # Frontend Pipeline Funcs |
| 后台管道函数 | vs         | # Backend Pipeline Funcs  |

#### 管道函数定义格式

```
PIPE <函数名>(param1(Type1),param2(Type2),...);RETURN returnVal1
-函数体
```

* 函数名使用 `_`前缀+ camelCase命名，比如 `_calculateTotal`

PIPE函数的参数格式与方法的参数格式要求完全一致。

#### 管道函数RETRUN结构

PIPE函数，仅作为数据处理转换使用，其RETURN结构可以根据当前的需求灵活处理，可返回所有数据类型系统中支持的类型，比如：

```vl
# Frontend Pipeline Funcs

PIPE _toUpperCase(inputString(STRING));RETURN STRING
-RETURN inputString.toUpperCase()

PIPE _checkPrice(price(STRING));RETURN BOOL
-RETURN (Number(price) > 30)

# Backend Pipeline Funcs

PIPE _trimAndValidateEmail(email(STRING));RETURN STRING
-_trimmed(STRING) = email.trim()
-IF _trimmed.includes("@")
--RETURN _trimmed
-ELSE
--RETURN ""
```

#### 函数的调用

所有函数**仅可在表达式中链式调用**，使用 `.` 操作符。详见函数调用示例章节。

### 事件

#### 事件的概念

事件是VL中响应用户交互或系统状态变化的核心机制。与方法不同，事件是被动触发的，当特定条件满足时自动执行其内部逻辑。事件通过事件处理器（Event Handler）来定义响应行为。

#### 事件处理器定义

所有事件处理器统一定义在 `# Frontend Event Handlers` / `# Backend Event Handlers`段落中，有两部分构成：

* 事件监听语句
* 事件处理主体

**定义格式：**

```vl
<组件类-组件名 "组件ID">.@事件名(参数1, 参数2...) // 事件监听语句
-事件处理主体
```

**格式说明：**

* 事件监听语句，无缩进
* 事件处理主体所有代码至少缩进一级 (`-`)
* 事件名称前必须带 `@` 符号

**命名规范：**

* 事件名称统一使用 **camelCase**
* 事件参数名称使用 **camelCase**
* 参数名称必须严格遵循组件文档中的定义

**事件主体编写规则**

事件处理主体本质上是一个方法，其编写规则（缩进、变量操作、方法调用、控制流、错误处理等）与方法完全相同，请参考"方法"章节。

#### RETURN 语句

* 事件处理器可以使用 `RETURN` 提前终止执行
* 事件处理器**无需返回值**，`RETURN` 后不跟任何内容

```vl
<Button-Submit "submitButton">.@click()
-IF !$canSubmit
--<SysUI>.showToast("Please complete required fields first", "warning")
--RETURN
-submitForm()
```

#### 事件参数

事件参数在事件监听语句中定义：

**何时需要声明参数：**

* 当事件处理主体中需要使用事件参数时，必须在事件监听语句的括号内声明参数
* 参数名使用 **camelCase（小驼峰）命名**

**何时可以省略参数：**

* 当事件处理主体中不需要使用任何事件参数时，括号内可以为空
* 例如：`@click()` 表示监听点击事件但不使用事件对象

**示例：**

```vl
# Frontend Event Handlers

// 需要使用事件参数
<Input-Username "usernameInput">.@change(newValue, oldValue)
-$username = newValue
-<SysUI>.consoleLog("Old value: " + oldValue)

// 不需要使用事件参数
<Button-Submit "submitButton">.@click()
-提交逻辑，无需使用@click的参数
```

**注意事项：**

* 事件参数无需声明类型（与方法参数不同）
* 事件参数名必须与组件文档中的定义完全一致
* 即使不使用参数，括号 `()` 也不能省略

#### 事件的触发机制

**禁止通过组件实例手动触发事件或调用 DOM 风格方法**

* 事件处理器由用户交互或组件状态变化**自动触发**，**无法在代码中手动调用**。
* 以下写法全部属于 **错误用法，严禁出现**：

```vl
# Frontend Event Handlers

// ❌ 错误：试图通过 DOM 风格方法触发按钮点击
<Button-Submit "submitButton">.click()

// ❌ 错误：把事件当方法手动调用
<Button-Submit "submitButton">.@click()
```

* VL 中 Button、Input 等 UI 组件**不暴露任何 `.click() / .focus() / .blur()` 等浏览器 DOM 方法**；
* 只能调用组件文档中明确声明的组件方法（例如某些列表组件的 `.scrollToBottom()` 等）。

**事件不支持传播**

VL 中的事件不支持事件冒泡或捕获机制。每个事件都是独立触发的：

```vl
# Frontend Tree
<Block-Container "container">
-<Button-Inner "innerButton"> value:"Click"

# Frontend Event Handlers

<Block-Container "container">.@click()
-<SysUI>.consoleLog("Container clicked")

<Button-Inner "innerButton">.@click()
-<SysUI>.consoleLog("Button clicked")

# 点击按钮时，只会触发按钮的 @click 事件
# 不会触发容器的 @click 事件
```

#### 循环中的事件处理

**循环内组件的id属性**

当需要监听一个循环容器下组件的事件时，无需关心多个循环创建的组件之间的对应关系，统一使用静态ID即可。

❌请严格禁止以下用法：`<Button-Action ("btn_" + _index0)> value:_item0.name`

✅直接使用静态ID：`<Button-Action "btn"> value:_item0.name`

**循环变量的使用**

在 `<For>` 或 `<TreeFor>` 循环容器内定义的组件的事件处理器中，可以直接使用循环变量：

```vl
# Frontend Tree
<For-UserList> sourceArray:$users loopVar:[_user0, _index0]
-<Block-UserItem>
--<Text-UserName> value:_user0.name
--<Button-Select "selectButton"> value:"Select"

# Frontend Event Handlers

<Button-Select "selectButton">.@click() //id为静态值
-$selectedUserId = _user0.id
-$selectedUserName = _user0.name
-<SysUI>.showToast(("Selected: " + _user0.name), "success")
```

**循环变量作用域**

循环变量 (`_itemX`, `_indexX`) 仅在 `<For>` 容器的直接子组件及其后代组件的事件处理器中有效：

```vl
# Frontend Tree
<For-TaskList> sourceArray:$tasks loopVar:[_task0, _index0]
-<Block-TaskItem>
--<Button-Complete "completeButton"> value:"Complete" //id为静态值

<Button-ShowAll "showAllButton"> value:"Show All"

# Frontend Event Handlers

# 正确：在循环内定义的按钮，可以使用循环变量
<Button-Complete "completeButton">.@click()
-$tasks[_index0].completed = true

# 错误：在循环外定义的按钮，不能使用循环变量
<Button-ShowAll "showAllButton">.@click()
-_task0.completed = true  # 错误！_task0 在此处不可用
```

## 表达式

#### 表达式中允许的操作

1. **算术运算符**: `+`, `-`, `*`, `/`, `%`, `**`
2. **比较运算符**: `==`, `!=`, `>`, `<`, `>=`, `<=`
3. **逻辑运算符**: `&&`, `||`, `!` (作用于布尔值)
4. **三元运算符**: `条件 ? 真值 : 假值`

```vl
$message = ($age >= 18) ? "Adult" : "Minor"
$complexResult = (($valueA > 10 && $valueB < 20) || $isOverride ? "Case1" : "Case2")
```

**属性值与派生表达式**：带运算符就必须括号；**控制语句条件（IF/ELSE IF/三元条件）**：最外层括号可省略，但复杂逻辑鼓励加括号，以提升可读性。

5. **访问变量**: `$globalVar`, `_localVar`, `_item0.field1`, `SYSENV.currentUser.userId`
6. **字符串拼接**: 使用 `+` 运算符。
   **重要规则**: 为了确保类型正确和避免潜在问题，进行字符串拼接时，如果表达式不以字面量字符串 (`"..."`或 `'...'`) 开头，**必须**在表达式开头添加 `"" +`。

```vl
$fullName = ($firstName + " " + $lastName)
$priceDisplay = ("" + "¥" + $price)
```

7. **调用 PIPE函数**:

* 示例: `_inputValue._trim()._toUpperCase()`

8. **调用变量内置immutable 方法**:
   这些方法**不能修改原始数据**，而是返回新的处理结果。

**示例:**

```vl
- _isValid(BOOL) = /^\d+$/.test($inputValue)
```

9. **使用箭头函数 (`=>`) 作为回调**:
   当系统默认的 immutable 方法（如 `filter`, `map`）需要回调函数时，**必须**使用箭头函数 (`=>`) 语法。**严禁**在表达式中使用 `function` 关键字来定义回调，**仅限 JS 内建 immutable 原型方法的回调**；

   ```vl
   // 正确做法:
   -_filteredOptions([{value:INT,label:STRING}]) = $stockOptions.filter( (item) => item.value > 10 )
   -_firstMatchingOption({value:INT,label:STRING}) = $stockOptions.filter( (option) => option.value === 100 )[0]
   ```

#### 核心禁止规则

**1. 绝对禁止在表达式中调用 METHOD**

任何以 `METHOD` 或 `METHOD_PUB` 定义的方法都不能在表达式中调用：

```vl
# ❌ 错误示例
<If-Check> conditions:(validateData())  # validateData 是 METHOD
<Text-Result> value:calculateTotal()    # calculateTotal 是 METHOD
$summary(STRING) = generateReport()      # generateReport 是 METHOD

# ✅ 正确做法：改用 PIPE 函数
PIPE _validateData(); RETURN BOOL
-RETURN ($formData.name != "" && $formData.email != "")

<If-Check> conditions:$formData._validateData()
```

**原因**：METHOD 可能包含副作用（如修改变量、调用服务），在表达式中调用会导致不可预测的行为和性能问题。

#### 表达式中的括号规则

**总则**：

所有表达式，如有运算符，必须带括号。否则就不带。

```vl
$message = ($age >= 18) ? "Adult" : "Minor"
<StateStyle-EmptyState> conditions:(!$hasData)
<Text-Time> value:_item0.time
```

### 复杂表达式示例 (包含循环变量)

```vl
# 访问循环项的属性
_item0.name
_user.profile.avatar

# 条件判断循环项属性
_item0.status == "active" ? "Online" : "Offline"

# 组合循环索引及循环项
("" + "Index:" + (_index0 + 1) + ", Name:" + _item0.name)
```

* `FOR...IN` 循环变量使用 `_` 前缀 + camelCase (e.g., `_itemX`, `_user`, `_product`) 和 `_indexX` (X从0开始)。
* 嵌套循环时索引变量递增为 `_item1`, `_index1`; `_item2`, `_index2` 等。
* 计数循环 `FOR` 循环变量命名**必须**使用 `_` 前缀 (e.g., `_i`, `_j`, `_counter`)。

## 逻辑编写基础规则

### 单向数据流规则（严格遵守）

在以下场景中，**下游数据由上游数据唯一决定**，下游数据无法独立于上游数据修改，**更不能反向经由下游数据来修改上游数据**。

#### 属性绑定的变量（上游） -> 组件属性（下游）

当一个组件的属性，绑定了一个变量时，这个变量成为唯一控制该组件属性的因素。如果要修改组件属性，必须修改其上游变量。

针对输入类的组件，此规则同样适用：假设一个输入类组件的value属性绑定了一个变量，当用户输入时，必须通过@change(), @blur(),@selected(),@input()等输入中/输入完成事件将当前用户输入的内容赋值给其绑定的变量。注意：VL中**不存在v-model语法糖**，所有数据修改必须显性完成。示例：

```
# Frontend Tree
-<Input-Name "nameInput"> value:$name // $name 仅负责初始化输入框显示的内容，不会自动随着用户输入而改变
-<Button-Submit "submitButton">

# Frontend Event Handlers

<Input-Name "nameInput">.@change(newValue,oldValue) // 关键！！ 必须使用输入框的事件来将用户输入的值重新赋值给变量
-$name = newValue

<Button-Submit "submitButton">.@click()
-submitName($name)
```

#### 全局变量（上游） -> 派生变量（下游）

派生变量唯一的计算依据是其定义时依赖的全局变量，无法在后续操作中独立赋值，示例：

```
# Frontend Global Vars
$users([{}]) = [{}]

# Frontend Derived Vars
$userCount = $users.length

# Frontend Event Handlers
<Button-Count "countButton">.@click()
-$userCount = $users.length + 1 // 严重错误， $userCount唯一由$users计算而来，不能在后续方法中操作
```

#### 循环数据源（上游） -> 循环变量（下游）

循环变量是对循环数据源的引用，其值完全由循环数据源决定，无法独立修改。示例：

```
// 循环结构容器示例
# Frontend Tree
-<For-ItemList> sourceArray: $list loopVar:[_item0,index0]
--<Text-Name "itemName"> value:_item0.name
--<BinaryToggle_Checkbox-Checked> value:_item0.checked

# Frontend Event Handerls
// 错误的做法：直接在事件中修改循环变量的值
<Text-Name "itemName">.@click()
-_item0.checked = true // 错误！_item0循环变量不能单独修改

//正确的做法：修改循环数据源
<Text-Name "itemName">.@click()
-$list[_index0].checked = true //修改循环数据源
```

#### 方法/函数/事件参数声明（上游） -> 方法/函数体内参数使用（下游）

方法和事件的参数在方法签名/事件定义时声明后，后续的使用是对其声明的单向引用，无法在事件/方法体中对入参进行任何修改。示例：

**正确的做法：**

```
METHOD manageList(items([STRING]), newItem(STRING)); RETURN {updatedList:[STRING], success:BOOL}
-_listCopy([STRING]) = items.slice() // items作为入参不能修改，只能被读取，或者使用其immutable方法来获取基于其的一个衍生数据
-_listCopy.push(newItem) //读取入参newItem
-_listCopy.splice(0, 1)
-_listCopy.sort()
-RETURN {updatedList:_listCopy, success:true}

METHOD updateTimestamp(timeVar(TIMESTAMP)); RETURN {newTime:TIMESTAMP, success:BOOL}
-_localTime(TIMESTAMP) = timeVar // timeVar作为入参不能修改，只能被读取
-_localTime.setUnixS(1700000000)
-RETURN {newTime:_localTime, success:true}
```

**错误或无效的做法：**

```vl
METHOD attemptModifyList(originalList([INT]), valueToAdd(INT));RETURN {success:BOOL}
-originalList.push(valueToAdd) // 错误，不能对入参进行mutable操作
-RETURN {success:false}

SERVICE ListPatientVisits(patientId(INT),page(INT),pageSize(INT));RETURN {...}
-IF page <= 0
--page = 1 //不可以直接对入参进行赋值，必须通过另一个局部变量进行过度
...
```

### 条件判断使用规则 (`IF / ELSE IF / ELSE`)

`IF` 语句用于基于**布尔表达式**进行条件分支，可以处理更复杂的条件逻辑。

**缩进规则:**

* `IF 布尔表达式` 语句与其所在代码块的当前行保持**相同缩进** (e.g., `-`)。
* `ELSE IF 布尔表达式` 和 `ELSE` 关键字也与 `IF` 保持**相同缩进** (e.g., `-`)。
* `IF`, `ELSE IF`, `ELSE` 内部的执行代码块，比其关键字 **深一级缩进** (e.g., `--`)。嵌套的 `IF` 会继续增加缩进。

```
-IF 条件1
--执行代码块1
---IF 嵌套条件1.1
----...
-ELSE IF 条件2
--执行代码块2
---...
-ELSE
--默认执行代码块
---...
```

**示例 1: 简单 IF/ELSE**

```vl
METHOD checkAge(age(INT)); RETURN {canVote:BOOL}
-IF age >= 18
--RETURN {canVote:true}
-ELSE
--RETURN {canVote:false}
```

**示例 2: IF / ELSE IF / ELSE 嵌套**

```vl
# Frontend Internal Methods

PIPE _extractTypes(input([{type:STRING, name:STRING}]));RETURN [STRING]
-_types([STRING]) = []
-_seen({}) = {}
-FOR (_item0, _index0) IN input 
--IF !_seen[_item0.type]
---_seen[_item0.type] = true
---_types.push(_item0.type)
---IF _item0.type == "INT"
----_types.push("INT")
---ELSE IF _item0.type == "BOOL"
----_types.push("BOOL")
--ELSE IF _item0.type == "STRING"
---_types.push("STRING")
---IF _item0.type == "INT"
----_types.push("INT")
---ELSE
----_types.push("STRING")
--ELSE
---_seen[_item0.type] = true
-RETURN _types
```

### 循环使用规则 (`FOR`)

VL支持三种 `FOR` 循环结构：

* **在前端组件树（# Frontend Tree）中：** 使用 ` <For>`, <`TreeFor>`等循环结构容器，可以循环创建其子组件
* **在方法/函数体中：** 使用循环语法 `FOR...IN` 和 `FOR(...)`可以进行逻辑的数组循环和计数循环

##### 1. 组件树中的循环结构容器(`<For>` , `<TreeFor>`)

使用 `<For/TreeFor-容器名 sourceArray:遍历数组 loopVar:[_itemN,_indexN]>` 来创建，详见组件使用文档。

* 注意：在循环结构容器的属性中，声明的 `loopVar` 属性中的局部循环变量，不需要预先定义。
* 循环变量请统一使用_itemN和_indexN的格式，其中N代表嵌入的层数，从0开始。比如，第一层循环，循环变量为_item0, _index0

##### 2. 方法/函数中的数组循环 (`FOR ... IN`)

使用 `FOR ... IN ...` 关键字来遍历数组。

**缩进规则:**

* `FOR (_itemVarN, _indexVarN) IN 数组变量` 语句与其所在代码块的当前行保持**相同缩进** (e.g., `-`)。
* 循环体内部的代码块，比 `FOR` 语句 **深一级缩进** (e.g., `--`)。
* 循环变量可以直接使用，不需要也不能预先定义
* 循环项变量和索引变量**必须**使用 `_` 前缀 + **camelCase**. 索引变量建议使用 `_indexN` (X 从 0 开始递增, e.g., `_index0`, `_index1`). 循环项变量可以根据上下文命名 (e.g., `_user0`, `_product1`, `_noteItem0`) 或使用 `_itemN` 进行通用迭代 (e.g., `_item0`, `_item1`, `_item2`)。注意，无论使用_item或根据上下文命名，为了避免重复，都请在变量后添加嵌套次数N（从0开始）。例如: `FOR (_user0, _index0) IN $userList` 或 `FOR (_dataItem1, _index1) IN dataArray`。
* **循环变量作用域**: 循环变量 (`_itemN`, `_indexN`) 仅在 `FOR...IN` 容器的直接子组件及其后代组件的属性绑定和条件表达式中有效。在 `FOR...IN` 外部，或在非 `FOR...IN` 内部静态定义的组件事件处理器中，引用这些循环变量是错误的。

**语法:**

```
-FOR (_itemVarN, _indexN) IN 数组变量
--循环执行代码
--...
```

**示例:**

```vl
METHOD calculateTotalAge(userList([{name:STRING, age:INT}])); RETURN {totalAge:INT, success:BOOL}
-_totalAge(INT) = 0
-FOR (_user0, _index0) IN userList
--_totalAge = _totalAge + _user0.age
-RETURN {totalAge:_totalAge, success:true}
```

嵌套 `FOR...IN` 循环时，每一层 `FOR` 都会增加一级缩进，且循环变量 `X` 递增：

```vl
METHOD processCategories(categories([{name:STRING, products:[{name:STRING, price:FLOAT}]}])); RETURN {processed:BOOL}
-FOR (_category0, _index0) IN categories
--log(("Processing category: " + _category.name))
--FOR (_product1, _index1) IN _category.products
---log(("-- Processing product: " + _product.name))
-RETURN {processed:true}
```

##### 3. 方法/函数中的计数循环 (`FOR (...)`)

提供类似 C/Java/JavaScript 的 `for` 循环结构，包含初始化、条件判断和增量/减量表达式。

**缩进规则:**

* `FOR (初始化; 条件; 增/减量)` 语句与其所在代码块的当前行保持**相同缩进** (e.g., `-`)。
* 循环体内部的代码块，比 `FOR` 语句 **深一级缩进** (e.g., `--`)。
* 循环控制变量在初始化部分声明，使用 `_varName(TYPE) = initialValue`。**必须**声明类型，**无** `let` 关键字。**必须**使用 `_` 前缀 + **camelCase** 名称 (e.g., `_i`, `_j`, `_k`, `_loopCounter`)。

**语法:**

```
-FOR (_loopVar(TYPE) = initialValue; loopCondition; incrementExpression)
--循环执行代码
--...
```

* **`_loopVar(TYPE) = initialValue`**: 初始化语句，声明并初始化循环变量。**必须**包含类型声明和 `_` 前缀。
* **`loopCondition`**: 循环继续执行的条件，是一个返回 `BOOL` 的表达式。
* **`incrementExpression`**: 每次循环迭代后执行的表达式，通常用于修改循环变量 (e.g., `_i++`, `_i--`, `_i = _i + 2`)。

**示例:**

```vl
# Frontend Event Handlers

<Button-LoopDemo "loopDemoButton">.@click()
-<SysUI>.consoleLog("--- FOR loop 0 to 9 ---")
-FOR (_i(INT) = 0; _i < 10; _i++)
--<SysUI>.consoleLog(_i)

-<SysUI>.consoleLog("--- FOR loop with step 2 ---")
-FOR (_step(INT) = 0; _step < 10; _step = _step + 2)
--<SysUI>.consoleLog(_step)
```

### 表单的制作规范

VL中的表单遵循**单向数据流**原则，通过输入组件事件反写对应的全局变量来实现数据的实时收集。表单制作分为两种场景，根据表单字段数量选择不同的实现策略。

#### 核心原则

**数据绑定规则：**

* 输入组件的 `value` 属性绑定全局变量作为初始值
* 通过输入组件事件（如 `@change()`, `@input()` 等）反写全局变量
* VL中不存在 v-model 语法糖，所有数据修改必须显式完成

**表单验证规则：**

* 验证逻辑放在派生变量（表达式太复杂时可使用PIPE函数）或前端内部方法中
* 验证结果控制提交按钮的 `disabled` 属性

#### 场景一：字段数量 ≤ 3 个（直接搭建）

直接在组件树中声明输入类组件，每个对应一个全局变量。

**示例：简单登录表单**

```vl
# Frontend Global Vars
$username(STRING) = ""
$password(STRING) = ""

# Frontend Derived Vars
$isFormValid(BOOL) = ($username != "" && $password.length >= 6)

# Frontend Tree
<Block-FormContainer>
-<Input-Username "usernameInput"> value:$username type:"text"
-<Input-Password "passwordInput"> value:$password type:"password"
-<ButtonContainer-Submit "submitButton"> disabled:(!$isFormValid)
--<Text-SubmitLabel> value:"Login"

# Frontend Event Handlers

<Input-Username "usernameInput">.@change(newValue, oldValue)
-$username = newValue

<Input-Password "passwordInput">.@change(newValue, oldValue)
-$password = newValue

<ButtonContainer-Submit "submitButton">.@click()
-IF !$isFormValid
--<SysUI>.showToast("Please complete the form", "warning")
--RETURN
-userlogin($username, $password) -> _result
```

#### 场景二：字段数量 > 3 个（循环构建 + 自定义组件）

* 使用 `<For>` 和 `$formFields`循环动态创建输入组件，制作一个自定义的动态字段组件（通过type属性来切换当前需要显示的输入组件类型），统一管理字段的输入和事件
* 动态字段的输入完成事件，将当前输入值回写至 `$formData`，然后调用一个 `validate`方法，将当前所有的验证错误写入至 `$errors`
* 通过 `$errors`来实时显示某个字段后的错误提示，并控制提交按钮是否可以提交

**示例：多字段用户注册表单**

```vl
<Section-UserRegistration "root">

# Frontend Global Vars
$formFields([{name:STRING,label:STRING,type:STRING,options:[{label:STRING,value:STRING}]}]) = [{name:"username",label:"Username",type:"text"},{name:"email",label:"Email",type:"text"},{name:"password",label:"Password",type:"password"},{name:"confirmPassword",label:"Confirm Password",type:"password"},{name:"phone",label:"Phone Number",type:"tel"},{name:"role",label:"Role",type:"select",options:[{label:"Regular User",value:"user"},{label:"Premium User",value:"vip"}]}]
$formData({username:STRING,email:STRING,password:STRING,confirmPassword:STRING,phone:STRING,role:STRING}) = {username:"",email:"",password:"",confirmPassword:"",phone:"",role:""}
$errors({username:STRING,email:STRING,password:STRING,confirmPassword:STRING,phone:STRING,role:STRING}) = {username:"",email:"",password:"",confirmPassword:"",phone:"",role:""}
$canSubmit(BOOL) = false

# Frontend Tree
<Block-RegistrationForm>
-<For-FormFields> sourceArray:$formFields loopVar:[_field0, _index0]
--<Block-FieldWrapper>
---<Text-Label> value:_field0.label styleClass:".."
---<Component-FormField "formField"> fieldName:_field0.name type:_field0.type fieldValue:$formData[_field0.name] fieldOptions:_field0.options
---<If-HasError> conditions:($errors[_field0.name] != "")
----<Text-Error> value:$errors[_field0.name] styleClass:".."
-<Button-Submit "submitButton"> value:"Register" disabled:(!$canSubmit) styleClass:".."

# Frontend Event Handlers

<Custom_DynamicField-FormField "formField">.@fieldChange(fieldName, newValue)
-$formData[fieldName] = newValue
-validateForm() -> _validation
-$canSubmit = _validation.canSubmit

<Button-Submit "submitButton">.@click()
-registerUser($formData) -> _result
-IF _result.success
--<SysUI>.showToast("Registration Successful", "success")

# Frontend Internal Methods

METHOD validateForm(); RETURN {canSubmit:BOOL}
-$errors = {}
-IF $formData.username == ""
--$errors.username = "Username cannot be empty"
-ELSE IF $formData.username.length < 3
--$errors.username = "Username must be at least 3 characters"
//其他字段的验证逻辑，此处省略
-_hasErrors(BOOL) = ($errors.username != "" || $errors.email != "" || $errors.password != "" || $errors.confirmPassword != "" || $errors.phone != "")
-_allFilled(BOOL) = ($formData.username != "" && $formData.email != "" && $formData.password != "" && $formData.confirmPassword != "" && $formData.phone != "")
-RETURN {canSubmit:(!_hasErrors && _allFilled)}

</Section-UserRegistration>
```

#### 对比总结

| 方面     | 字段 ≤ 3 个     | 字段 > 3 个                                      |
| -------- | ---------------- | ------------------------------------------------ |
| 组件声明 | 直接在组件树中   | 使用 ``+``                                       |
| 数据存储 | 多个独立全局变量 | 单个 `$formData` 对象                          |
| 事件处理 | 各字段独立       | 统一通过循环内的表单字段（通常是一个自定义组件） |
| 验证逻辑 | 派生变量         | 前端内部方法                                     |

#### 错误处理

**使用系统默认错误处理**（推荐）：

- 标准的CRUD操作
- 简单的数据获取
- 不需要特殊错误恢复逻辑

**使用 `IF`自定义判断**

- 需要根据特定错误类型进行不同处理
- 需要在错误时执行清理操作
- 需要记录详细的错误日志

在**方法调用**或**服务调用**后有两种错误处理方式：

**1、系统默认错误处理机制**

无需显性声明错误处理逻辑，任何方法调用，只要上一步返回结果的success字段不等于true，就会进行默认系统错误处理。处理逻辑包括：

* 当前方法/事件 RETURN
* 如果当前方法/事件的返回参数里有success和message字段，那么会返回success:false, message:上一步返回结果.message
* 如果当前方法/事件是前端调用的，那么会自动调用SysUI的方法，将上一步返回结果的错误信息提示处理
* 以上三点都是系统自动处理，用户不需要额外声明IF语句以及后续的处理语句
* 无特殊需求，请直接使用系统默认错误处理，简化代码
* 推荐使用系统默认错误处理；只用当用户觉得需要单独对错误进行处理时，才使用IF特殊判断

**2、手动错误处理机制**

使用 `IF` 来手动判断错误处理逻辑

**自定义错误处理示例:**

```vl
SERVICE GetData(pageNum(INT), pageSize(INT), keyword(STRING));RETURN {success:BOOL, message:STRING, data:[{_id:INT,pic:STRING,price:STRING,title:STRING,address:STRING,desc:STRING}], total:INT}
-<VirtualTalbe-List "listDataTable">.count([["title","*contains",keyword]]) -> _countResult
-IF !(_countResult.count>0)
--RETURN {success:false,message:_countResult.message,data:null,total:0}

-_count(INT) = _countResult.count
-_offset(INT) = (pageNum - 1) * pageSize
-<VirtualTalbe-List "listDataTable">.select([["title","*contains",keyword]],null,[_offset,pageSize]) -> _selectResult
-IF _selectResult.dataArray.length == 0
--RETURN {success:false,message:_selectResult.message,data:null,total:0}

-RETURN {success:true,message:"",data:_selectResult.dataArray,total:_count}
```

**前端错误处理示例 (结合状态更新和用户提示):**

```vl
# Frontend Global Vars

$isLoading(BOOL) = false
$hasError(BOOL) = false
$errorMessage(STRING) = ""
$userData({}) = {}

# Frontend Event Handlers

<Button-LoadUser "loadUserButton">.@click()
-$isLoading = true
-$hasError = false
-$errorMessage = ""
-getUserData($userId) -> _result
-IF !_result.success
--$isLoading = false
--$hasError = true
--$errorMessage = _result.message
--<SysUI>.showToast(("" + "Load failed: " + _result.message), "error")
--RETURN

-$userData = _result.data
-$isLoading = false
-<SysUI>.showToast("User data loaded successfully", "success")
```

- 在IF错误处理块中通常有以下逻辑：
  * 更新相关的状态变量（如 `$isLoading = false`, `$hasError = true`）。
  * 更新用于显示错误信息的变量（如 `$errorMessage`）。
  * 使用 `<SysUI>.showToast` 或 `<SysUI>.showModal` 给用户反馈 (确保提示信息包含字符串字面量 `"" + ...`，且作为表达式，用括号包裹)。
  * 根据逻辑需要决定是否 `RETURN` 提前退出。

## 样式定义

#### 样式配置整体规则

**1、StyleClass优先于属性单独覆盖**

* 推荐先在项目Theme文件中定义 `# Component Styles`（组件预置样式），然后在 `# Frontend Tree`中，使用StyleClass属性来引用，比如 `<Block-ListContainer> styleClass:"CardDefault"`，`<Text-Title> styleClass:"TextLarge"`
* 注意：styleClass属性仅需要包含对应预置样式的名称，不需要包含类。比如在.vth的#component style中，一个预置样式定义为 `<Button-ButtonPrimary>`，在引用时，直接使用 `"ButtonPrimary"`作为styleClass属性值，而不是 `"Button-ButtonPrimary"`
* 注意：一个组件仅能使用其对应类的StyleClass，比如Text组件不能使用Block组件的StyleClass
* 如组件预置样式不能满足需求，则在 `# Frontend Tree`下的组件属性中单独覆盖

**2、ThemeToken优先于字面值**

* 无论在Theme文件的 `# Component Styles`中或在前端文件的 `# Frontend Tree`中，优先使用ThemeToken，如 `--colorBrandPrimary`，`--spacing4`
* 仅当一个样式属性在 `Theme.vth`中没有对应的Token，方使用字面值，字面值使用规则与CSS规则一致，比如 `width:100px`，`color:red`

**3、动态样式规定（严格）**

* 优先使用动态StyleClass属性，比如 `StyleClass:($selected?"TextSelected":"TextNormal")`
* 如动态StyleClass不能满足需求，则可在组件覆盖CSS样式属性中，使用VL表达式，比如：`<Block-ProgressBar> width:("" + $progress*300 +"px")` 注意：VL表达式仅支持在普通组件实例中定义，**`StateStyle`挂件为静态样式配置，不允许使用VL表达式**
* **严禁在事件/方法中直接访问/修改组件样式**

```
# ❌ 错误做法
-<Text-Title "title">.color = "blue" // 禁止直接修改组件样式
-_textColor = <Text-Title "title">.color // 禁止读取组件的样式
-<Text-Title "title">.style.color = "blue" //不存在.style.样式名 这种访问方式

# ✅ 纠正
//首先在组件树中将需要动态修改的样式进行绑定：
<Text-Title "title"> value:"Hello" color:$color
//然后修改绑定的变量：
-$color = "blue"
```

#### 复合属性使用规则

* **允许的复合值属性 (保持完整)**: `box-shadow`, `transform`, `clip-path`, `filter`, `text-shadow`, 以及 `background-image` (用于渐变) 和 `grid-template-columns/rows/areas` 等属性的值本身就是复合结构，**必须**保持其完整的字符串形式。
  * `box-shadow:0 8px 25px rgba(0,0,0,0.15)`
  * `transform:translateY(-2px) scale(1.02)`
  * `filter:blur(5px) brightness(0.8)`
  * `grid-template-columns:repeat(3, 1fr)`
* **禁止使用的多属性简写 (必须拆分)**:
  * `background` (应拆分为 `background-color`, `background-image`, `background-repeat` 等)
  * `border` (应拆分为 `border-width`, `border-style`, `border-color`)
  * `font` (应拆分为 `font-size`, `font-family`, `font-weight` 等)
  * `transition` (应拆分为 `transition-property`, `transition-duration` 等)
  * `flex` (应拆分为 `flex-grow`, `flex-shrink`, `flex-basis`)
  * 以及其他类似的捆绑型简写。
* **允许使用的多方向简写 (遵循"二选一"规则)**:
  * `padding`, `margin`, `overflow`, `border-radius`, `gap`
  * **"二选一"原则**: 如果使用了这些简写形式（如 `padding:"10px"` 或 `padding:"10px 20px"`），则在同一个样式规则集内**禁止**再使用其对应的单边属性（如 `padding-left`）。
* **复合属性使用示例：**

```
// 错误（禁止简写）
<Block-Card> border:1px solid #eee
// 正确（拆分）
<Block-Card> border-width:1px border-style:solid border-color:#eee
```

#### **VL中禁止使用的CSS属性**:

* **媒体查询 (强制禁止)**: **严禁**在任何样式定义中使用 `@media` 查询。iVX的设计哲学是为每个目标设备（PC, Phone, Pad）创建独立的应用，而不是在单个应用内进行响应式适配。
* **动画关键帧**: 只有 **@keyframes** `动画`、**animation** `属性`VL语法不支持，其它CSS样式均支持。
* **display**: `display` 属性完全由组件内部管理, 不允许直接写 `display:xxx`

### `<StateStyle>`条件样式挂件

条件样式挂件，通过其Conditions和Trigger属性，可以清晰的指定一个UI组件在不同场景下的样式。注意：条件样式挂件的样式定义，仅支持使用字面量和calc表达式，严格限制使用VL表达式。

#### 不能添加样式的组件

以下组件是纯逻辑容器，本身不带任何DOM元素。因此不能在这些组件上添加任何样式定义（即尖括号 `<...>` 外部不能内容）。请认为这些组件在排版时是"透明的"，完全不参与UI元素排版。这些组件包括： `If`, `For`, `TreeFor`, `AnimationGroup` (以及其他类似的纯逻辑循环或条件渲染组件)。

## DataBase文件规则

### Table定义

**示例**

```vl
<Table-Users> data:[{"_id":1,"username":"user1","email":"user1@example.com","role":"Admin","status":1,"_user":"1","_create":"2024-01-15 09:30:00","_update":"2024-01-15 09:30:00"}...]
-<Field-username> type:STRING
-<Field-email> type:STRING
-<Field-role> type:STRING
-<Field-status> type:INT
```

**规则**

* 表名**大驼峰**，字段名**小驼峰**
* `default` 支持字面量：字符串需引号（如 `default:""`）、布尔（`true|false`）、数值、时间字符串等。
* 以下系统字段会**在系统建表时自动添加**，**禁止显式声明同意义字段**：
  * `_id（INT）`: 自增主键，从1开始
  * `_user（STRING）`: 记录提交用户的ID
  * `_create（TIMESTAMP）`: 创建时间
  * `_update（TIMESTAMP）`: 更新时间
* `vecSource` 为向量类型字段专有属性，指定了向量字段的原始数据字段。
* `Index` 为可选子组件；索引字段顺序生效。
* `data` 为可选属性；用于初始化一些测试数据。请根据实际需求初始化3-7行数据。与正常在服务内insert/update不同，测试数据需要声明系统字段以方便测试：
  * `_id`字段：必填，请从1开始；
  * `_user`字段：必填，如无特殊要求，请固定为"1"；
  * `_create`/`_update`字段: 必填，如无特殊要求，请固定为当前时间

### Relation定义

**格式**

```
<Relation-关系名称 关系1 关系2 ..>
```

**示例**

```
<Relation-User&Profile> users._id--userProfiles.userId // 一对一单一关系
<Relation-User&Posts> users._id<<posts.authorId  // 一对多，单一关系
<Relation-User&Messages> users._id<<messages.senderId users._id<<messages.receiverId // 一对多，多线关系
<Relation-Departments&Employees> departments._id<<employees.departmentId departments.managerId>>employees._id // 一对多+多一对双关系
<Relation-Warehouse&Inventory> warehouses.(code,region)<<inventory.(warehouseCode,warehouseRegion) // 一对多，单一关系复合键
```

* 一个Relation描述了两个表之间的所有关系，关系名称请严格参照表名。比如，`<Relation-表名1&表名2>`， 两个表名之间用 `&`符号连接。
* 两个表之间可能有多个关系
* 每个关系包含表1的字段、关系符号和表2的字段
* 关系符号通过 `--`、 `<<`和 `>>`表示，分别代表一对一、一对多和多对一
* 一个关系可能包含复合键，注意，复合键的多个字段其实代表一个指向，因此请使用 `表1.(复合键构成字段1,复合键构成字段2...)` 这种格式来表示，切勿写成两个关系。

## App（.vx）应用文件编写补充说明

### `#SysConfig` (应用系统配置)

`.vx`应用文件必须在 `#SysConfig` 部分声明系统配置参数：

```vl
# SysConfig

DEVICE_TARGET:"PC"
SCREEN_RESOLUTION:"1920x1080"
```

**必须配置项：**

- **DEVICE_TARGET**: 目标设备类型，可选值："PC", "Phone", "Pad"
- **SCREEN_RESOLUTION**: 目标屏幕分辨率

## Section/Component（.sc/.cp）文件编写补充说明

### `# Frontend Public Props`（公共属性定义）

使用前端全局变量 (`$`) 定义公共属性变量，这些变量在文件内部的使用方式与普通全局变量一致，但在应用编译时，公共属性变量的值可由上层文件（App或Sectoin）传入。

**定义方法：**

```vl
# Frontend Public Props
$属性名(类型) = 初始值
```

**示例:**

```vl
# Frontend Public Props
$initialConfig({primaryColor:STRING,fontSize:INT}) = {primaryColor:"#1890ff",fontSize:14}
$initialUserId(INT) = 0
```

### `# Frontend Tree`

**禁止**：Section中绝对禁止再添加另外的Section，即Section的Frontend Tree中不会出现 `<Section-模块名>...`这样的语句。

### `# Frontend Public Events`（前端公共事件定义）

在.sc/.cp文件中，可定义公共事件，即模块内部向外发送的事件，这些事件在应用层（.vx文件）中可被监听到，以完成模块/组件间的交互。其定义分成两部分：

1、首先在 `# Frontend Public Events` 部分，顶层，无缩进,使用 `@` 符号定义事件方法的名称：

**定义格式:**

```
EVENT @eventName(param1(Type1),param2(Type2),...)
```

- **参数命名**: 所有参数使用 **camelCase**，**不带 `_` 前缀**。

**示例:**

```vl
EVENT @userSelected(userId(INT),userName(STRING))
EVENT @formSubmitted(formData({id:INT,timestamp:TIMESTAMP}))
EVENT @requestLogin()
```

2、然后在在.sc/.cp文件的程序逻辑内部（通常在事件处理器或方法内），定义其触发逻辑：

```vl
<Button-Submit "submitButton">.@click()
-validateForm() -> _validation
-IF _validation.success
--@formSubmitted($formData)
-ELSE
--<SysUI>.showToast(_validation.message, "error")
```

### `# Frontend Public Methods`（前端公共方法定义）

在.sc/.cp文件中，可将某个方法定义为公共方法，注意使用 `METHOD_PUB MethodName`格式。

这些方法可供上层应用文件（.vx/.sc）调用。

公共方法，也可在文件内部调用，调用方式和内部方法完全一致：

```
# Frontend Public Methods

METHOD_PUB Hide();RETURN {success:BOOL}
-$isVisible = false
-@modalClosed()
-RETURN {success:true}

# Frontend Event Handlers
<Button-Close "closeButton">.@click()
-Hide() //直接调用方法，不要将公共方法勿当成根组件的方法
```

注意：在文件内部调用公共方法时，切勿将公共方法勿认为是文件根组件的方法。比如在Section内部，**不存在这种 `<Section-MyModule>.Hide()`这种调用方式**。

### 在Section中调用服务

Section文件，可以调用同一个project下的任意ServiceDomain文件中定义的服务。调用方式如下：

1、在组件树中添加需要使用的ServiceDomain，作为一个功能性组件加入：

```
# Frontend Tree

<ServiceDomain-服务域名 "服务ID"> // 首先引入服务域组件
-<Service-服务名1> params:(入参1(类型),入参2(类型)...) returns:(出参1(类型),出参2(类型)...) // 引入需要的服务，并将其入参和出参作为组件属性
-<Service-服务名2> ...// 服务域下另一个服务
```

2、在Section的事件处理或方法中，调用这个ServiceDomain中定义的服务：

```
<ServiceDomain-服务域名 "服务ID">.服务名()
```

3、完整示例：

```
# Frontend Tree
<ServiceDomain-Doc "docService"> // 首先引入服务域组件
-<Service-DeleteDocument> params:(docId(INT),deleteType(BOOL)) returns:(success(BOOL),message(STRING)) // 引入需要的服务，并将其入参和出参作为组件属性
...

<Button-Logout "logoutButton">.@click()
-<ServiceDomain-Doc "docService">.DeleteDocument() -> _out
-<ClientUtils>.switchRoute("home")
```

## ServiceDomain（.vs）定义补充说明

### 虚拟表定义

虚拟表是VL中后台服务逻辑操作真实数据库表的"中间client"， VL秉承代码逻辑与数据源定义分离的原则，在服务代码中不能直接操作数据库表，必须通过虚拟表VirtualTable作为桥梁。通过虚拟表中的sourceField属性来指定虚拟表-实体表的对应关系。

**格式：**

```
<VirtualTable-表名 "组件ID"> extraSpecs?:{specName1(类型):"属性描述"..} sourceTable:对应的实体主表
-<Field-字段名> type:字段类型 vecSource?:["虚拟表字段1","虚拟表字段2"] sourceField?:对应的实体表字段 额外属性1:属性值.. // Field作为VirtualTable的子项，必须额外缩进一格
```

**示例:**

```vl
<VirtualTable-Users> "userTable" sourceTable:GroupUsers extraSpecs:{label(STRING):"Field Label",readOnly(BOOL):"Read Only",inputType(STRING):"Input Type"} mockData:[{..}]
-<Field-_id> type:INT label:"User ID" readOnly:true
-<Field-username> type:STRING label:"Username" inputType:"text" // 不指定sourceField代表直接关联主表中同名字段
-<Field-email> type:STRING sourceField:userEmail label:"Email" inputType:"email" //指定sourceField，以适配数据源字段与虚拟表字段名称不一致的情况
-<Field-departmentName> type:STRING sourceField:departmentId~Departments[_id].name label:"Department Name" readOnly:true //根据关联关系找到
-<Field-managerName> type:STRING sourceField:departmentId~Departments[_id].managerId~Employees[_id].name label:"Manager Name" readOnly:true
-<Field-_create> type:TIMESTAMP label:"Creation Time" readOnly:true //系统字段，需要在当前虚拟表中设置label
```

**VirtualTable声明**

- 一个VirtualTable定义了一个服务域中的虚拟表，表名请依照VL风格，使用**大驼峰**，比如 `UserMessage`
- `id`: 必填，请以"xxTable"来命名，xx为当前表的独立唯一名称
- `sourceTable`: 绑定的实体表，一个虚拟表仅能绑定一个实体表（主表）
- `extraSpecs`: 可选属性。定义了虚拟表字段的额外属性, 这些属性会在select时作为 `structure`字段的一部分输出，用于前端渲染的额外信息。比如 `{comment(STRING):"字段描述",label(STRING):"字段标签显示",readOnly(BOOL):"是否只读"}`
- `mockData`:虚拟表测试数据，仅当ServiceDomain文件需要单独预览调试时，才需要设置

**Fields声明**

- 每一个 `Field`: 定义了其父级虚拟表的一个字段。字段名请使用**小驼峰**，比如 `userName`
- **本表字段**与**外表字段**
  - 本表字段，即关联了当前主表中的某个字段，如虚拟表字段名与主表字段名一致，则无需指定 `sourceField`属性，反之请通过 `sourceField`属性指定当前虚拟表字段关联的主表字段
  - 外表字段，请通过 `sourceField`属性依照实体表的关联关系设置一个字段路径（详见字段路径编写规则）
  - `sourceField`属性支持指向一个本表或外表的字段，**不支持表达式或聚合函数**
- 字段的**额外属性**必须先在 `extraSpecs`中进行定义
- **向量字段**：当字段类型为 `VEC`时，必须额外指定 `vecSource`属性
- **系统字段**:
  - `_id`,`_user`, `_create`, `_update` 是系统自动管理的字段（类型为 INT，STRING, TIMESTAMP, TIMESTAMP），不需要在虚拟表中声明也可以直接使用（比如作为select的筛选/排序条件和输出字段）
  - 如果需要给本表系统字段设置额外属性或别名，可在虚拟表的字段中声明，比如 `Field-docId type:INT sourceField:_id label:"创建时间" readOnly:true`
  - 无论是否声明，系统字段为**只读字段**，不允许在insert/update里指定值

#### **sourceField编写规则**

* 如当前虚拟表字段绑定当前主表的某个字段，且两者字段名称不一致，可在 `sourceField`属性中指定当前主表的字段名，比如 `<Field-title type:STRING sourceField:docTitle> // 虚拟表字段title对应当前主表实体表字段docTitle`
* 如当前虚拟表绑定其他关联表中的字段，请使用 `~`跳表符，代表从当前表"沿着"Relation找到另一个表， 格式为：`本表起始字段~关联表[描点字段].目标字段`

  * 单跳：`<Field-departmentName> type:STRING sourceField:departmentId~Departments[_id].departmentName`
  * 多跳：`<Field-managerName> type:STRING sourceField:departmentId~Departments[_id].managerId~Users[_id].userName`
* 任何一跳，都必须有对应的Relation，且这个Relation必须是多对一或一对一，否则将造成数据膨胀

**正确示例**

```vl
sourceField:departmentId~Departments[_id].managerId~Users[_id].userName
            └─────┬─────┘ └─────┬─────┘└────┬────┘ └──┬──┘└───┬───┘
               第1跳起始    第1跳锚点   第2跳起始  第2跳锚点  取值字段
```

**第1跳**：`departmentId~Departments[_id]`

```
查找 Relation: <Relation-Employees&Departments> employees.departmentId>>departments._id
方向检查: >> (多对一) ✅
```

**第2跳**：`managerId~Users[_id]`

```
查找 Relation: <Relation-Departments&Users> departments.managerId>>users._id
方向检查: >> (多对一) ✅
```

**最终结果**：取 `users.userName` 字段

**错误示例**

```vl
// ❌ 错误：包含一对多跳转
sourceField:_id~Orders[userId].amount
            └┬┘ └──┬──┘└──┬──┘└──┬──┘
          起始  目标表  锚点  取值字段
```

**错误原因**

```
查找 Relation: <Relation-Users&Orders> users._id<<orders.userId
方向检查: << (一对多) ❌

编译错误：
"sourceField 路径包含一对多关系 (users._id << orders.userId)"
"一对多会导致单条记录映射到多条关联记录，产生数据重复"
"建议：将 Orders 设为主表，然后跳转到 Users"
```

#### 外表字段只读访问规则

当一个字段为外表字段时，该字段仅能读取，不支持写入。

**❌错误示例**

```vl
<VirtualTable-Orders> "orderTable" sourceTable:Orders
-<Field-productName> type:STRING sourceField:productId~Products[_id].name // 外表字段
-<Field-quantity> type:INT // 本表字段

SERVICE CreateOrder(productId(INT),quantity(INT),productName(STRING));RETURN {success:BOOL,orderId:INT}
-_orderData({productId:INT,quantity:INT,productName:STRING}) = {productId:productId,quantity:quantity,productName:productName} // ❌ 错误！productName是外表字段，不能写入
-<VirtualTable-Orders "orderTable">.insert(_orderData) -> _result
-RETURN {success:true,orderId:_result.dataId}
```

### `# Services`（后端服务定义）

在vs文件中，所有可供外部调用的服务，请定义在 `# Services`章节下，前缀为 `SERVICE ServiceName`

每一个服务，都作为当前ServiceDomain的一个公共方法。这些方法可以在Section文件中被调用，调用的方法是：`<ServiceDomain-服务域名 "服务ID">.ServcieName()`

### `# Backend Event Handlers`（后端事件监听）

后端消息类型组件的消息处理逻辑定义。比如 `<SeverWSClient>`，<`MQ>`的消息事件。示例：

```
# Backend Event Handlers
<MQ-DataPipe "dataTransfrom">.@message(rawData,dataType)
-convertData(rawData,dataType) -> _result
-log(_result)
```

### `# Transactions`（数据库事务定义）

定义一个数据库操作事务，在事务中支持回滚操作，示例：

```
# Transactions
TRANSACTION txTransferMoney(fromId(INT), toId(INT), amount(FLOAT)); RETURN {success:BOOL, message:STRING}
-<VirtualTable-Accounts "accountTable">.select([["_id","eq",fromId]]) -> _fromAccount
-IF _fromAccount.dataArray[0].balance < amount
--ROLLBACK {success:false, message:"Insufficient balance"}
-<VirtualTable-Accounts "accountTable">.update([["_id","eq",fromId]], [["balance","inc",-amount]], 1) -> _updateFrom
-<VirtualTable-Accounts "accountTable">.update([["_id","eq",toId]], [["balance","inc",amount]], 1) -> _updateTo
-RETURN {success:true, message:"Transfer successful"}
```

* 命名使用小驼峰，并以 `tx`开头
* 使用ROLLBACK关键字来回滚事务
* 事务的使用方法完全同内部方法，不能像服务一样在前端直接被调用

**调用示例**

```
# 在Service中调用事务
SERVICE TransferMoney(fromUserId(INT), toUserId(INT), amount(FLOAT)); RETURN {success:BOOL, message:STRING}
-txTransferMoney(fromUserId, toUserId, amount) -> _result
-RETURN _result
```

### `# Backend Internal Methods`（后端内部方法定义）

定义后端内部方法，以METHOD为前缀, 格式与前端内部方法完全一致。

## App、Section、Component 的架构关系

### 三层架构概述

VL 采用 **App - Section - Component** 三层前端架构：

| 层级                | 文件类型 | 核心职责                                   | 可包含             |
| ------------------- | -------- | ------------------------------------------ | ------------------ |
| **App**       | `.vx`  | 应用入口、路由管理、全局状态、Section编排  | Section、Component |
| **Section**   | `.sc`  | 业务模块、数据交互、完整业务逻辑           | Component          |
| **Component** | `.cp`  | 纯UI复用、无业务逻辑、通过Props/Events通信 | 无                 |

### 层级关系图

```
App (.vx)
├── Page-Home
│   ├── Section-Header (.sc)
│   │   ├── Component-Logo (.cp)
│   │   └── Component-NavMenu (.cp)
│   ├── Section-ProductList (.sc)
│   │   ├── Component-ProductCard (.cp)
│   │   └── Component-Pagination (.cp)
│   └── Section-Footer (.sc)
└── Page-Detail
    └── Section-ProductDetail (.sc)
        └── Component-ImageGallery (.cp)
```

### 数据流向

```
App (全局状态 + 路由)
    ↓ Props传递
Section (业务逻辑 + ServiceDomain调用)
    ↓ Props传递
Component (纯UI渲染)
    ↑ Events上报
Section (处理事件 + 更新状态)
    ↑ Public Events上报
App (跨Section协调)
```

---

## Section、App、Component 的职责边界划分

### App（.vx）职责边界

**App 是什么：**

- 应用的唯一入口文件
- 负责页面路由和导航管理
- 负责 Section 的布局编排和组合
- 管理跨 Section 的全局状态

**App 应该做：**

- ✅ 定义 `Page` 组件和路由路径
- ✅ 在 Page 中添加和排版 Section
- ✅ 监听 Section 的公共事件（`@publicEvent`）
- ✅ 调用 Section 的公共方法（`METHOD_PUB`）
- ✅ 管理跨 Section 共享的全局变量
- ✅ 处理 Section 之间的通信和协调

**App 禁止做：**

- ❌ 直接调用 ServiceDomain（后台服务交互必须在 Section 中）
- ❌ 添加 `<For>`、`<TreeFor>` 等循环容器
- ❌ 包含复杂业务逻辑
- ❌ 直接添加基础 UI 组件（如 `<Button>`、`<Input>`）
- ❌ 在 Section 下嵌套子组件

**示例：**

```vl
// ✅ 正确：App 负责 Section 编排和跨 Section 通信
# Frontend Tree
<Page-Home "homePage"> path:"home"
-<Section-NavHeader "navHeader">
-<Section-ProductList "productList">
-<Section-Footer "footer">

# Frontend Event Handlers
<Section-NavHeader "navHeader">.@searchSubmit(keyword)
-<Section-ProductList "productList">.RefreshWithKeyword(keyword)
```

---

### Section（.sc）职责边界

**Section 是什么：**

- 独立的业务功能模块
- 包含完整的 UI + 数据 + 业务逻辑
- 可单独预览和调试
- 是与后台 ServiceDomain 交互的唯一前端层级

**Section 应该做：**

- ✅ 调用 ServiceDomain 获取/提交数据
- ✅ 包含完整的业务逻辑处理
- ✅ 使用 Component 构建 UI
- ✅ 定义公共属性（`# Frontend Public Props`）供 App 传值
- ✅ 定义公共事件（`# Frontend Public Events`）向 App 通信
- ✅ 定义公共方法（`METHOD_PUB`）供 App 调用
- ✅ 使用 `<For>`、`<If>` 等逻辑容器

**Section 禁止做：**

- ❌ 嵌套其他 Section（Section 之间是平等关系）
- ❌ 直接调用其他 Section 的方法
- ❌ 感知其他 Section 的存在
- ❌ 处理路由跳转（路由逻辑放在 App 层）

**示例：**

```vl
// ✅ 正确：Section 包含完整业务逻辑
<Section-ProductList>

# Frontend Public Props
$categoryId(INT) = 0

# Frontend Public Events
EVENT @productSelected(productId(INT))

# Frontend Tree
<ServiceDomain-Product "productService">
-<Service-GetProducts> params:(categoryId(INT)) returns:(success(BOOL),data([{}]))

<Col-ListContainer>
-<For-Products> sourceArray:$products loopVar:[_item0,_index0]
--<Component-ProductCard "card"> product:_item0

# Frontend Event Handlers
<Component-ProductCard "card">.@cardClick(productId)
-@productSelected(productId)
```

---

### Component（.cp）职责边界

**Component 是什么：**

- 纯 UI 展示组件
- 完全无业务逻辑
- 通过 Props 接收数据，通过 Events 向外通信
- 高度可复用的 UI 单元

**Component 应该做：**

- ✅ 接收 Props 并渲染 UI
- ✅ 通过公共事件向父级通信
- ✅ 处理纯 UI 交互（如 hover 效果、动画）
- ✅ 封装可复用的 UI 模式

**Component 禁止做：**

- ❌ 调用 ServiceDomain（绝对禁止）
- ❌ 包含任何业务逻辑
- ❌ 嵌套其他 Component
- ❌ 直接修改来自 Props 的数据

**示例：**

```vl
// ✅ 正确：Component 是纯 UI 组件
<Component-ProductCard>

# Frontend Public Props
$product({id:INT,name:STRING,price:FLOAT,image:STRING}) = {id:0,name:"",price:0,image:""}

# Frontend Public Events
EVENT @cardClick(productId(INT))

# Frontend Tree
<Block-Card> StyleClass:"ProductCard"
-<Image-ProductImage> sourceUri:$product.image
-<Text-ProductName> value:$product.name
-<Text-ProductPrice> value:("¥" + $product.price.toFixed(2))

# Frontend Event Handlers
<Block-Card>.@click()
-@cardClick($product.id)
```

---

### 三者对比总结

| 维度                           | App                 | Section             | Component  |
| ------------------------------ | ------------------- | ------------------- | ---------- |
| **核心职责**             | 路由 + Section 编排 | 业务逻辑 + 数据交互 | 纯 UI 展示 |
| **可调用 ServiceDomain** | ❌                  | ✅                  | ❌         |
| **可包含 Section**       | ✅                  | ❌                  | ❌         |
| **可包含 Component**     | ✅                  | ✅                  | ❌         |
| **可使用 For/If 容器**   | ❌                  | ✅                  | ✅         |
| **可直接添加 UI 组件**   | ❌                  | ✅                  | ✅         |
| **独立预览调试**         | ✅                  | ✅                  | ✅         |
| **感知其他同级模块**     | ✅（协调 Section）  | ❌                  | ❌         |

### 典型错误示例

```vl
// ❌ 错误1：App 中直接添加 UI 组件
<App-MyApp>
# Frontend Tree
<Page-Home>
-<Button-Submit> value:"Submit"  // 错误！App 不能直接添加 UI 组件

// ❌ 错误2：Section 中嵌套 Section
<Section-MainLayout>
# Frontend Tree
-<Section-Sidebar>  // 错误！Section 不能嵌套 Section

// ❌ 错误3：Component 中调用 ServiceDomain
<Component-UserCard>
# Frontend Tree
<ServiceDomain-User "userService">  // 错误！Component 禁止调用 ServiceDomain

// ❌ 错误4：App 中使用 For 循环
<App-MyApp>
# Frontend Tree
<Page-List>
-<For-Items> sourceArray:$items  // 错误！App 禁止使用 For 容器
```

## 用户登录与权限控制

#### 用户中心

VL系统统一提供用户中心应用，任何一个项目都会会自动绑定一个用户中心，不需要在VL中指定。用户中心提供以下功能：

* 用户注册、登录
* 用户信息编辑
* 管理员用户管理（用户列表查看，用户禁用/注销）
* 管理员用户权限配置（基于ABAC结合RBAC的权限管理系统，可配置资源组，管理资源组的访问规则等）

#### 应用与用户中心的交互

前端应用中，可以通过 `<ClientUserCenter>`组件调用用户中心的接口方法，以实现前端自定义登录界面相关功能。

前后端应用，都可以使用 `SYSENV.currentUser`来获取当前登录用户的信息。

#### 应用中不允许出现的逻辑

应用中的实体表、虚拟表、服务、前端元素的访问权限，会由管理员或一个独立的AI agent在用户中心的管理界面进行设置，因此**请勿在代码中hardcode任何用户权限相关的逻辑**，包括：

* 某个服务是否可以被访问
* 数据访问范围的限制，比如，是否只能访问到自己创建的数据，或者可以访问到当前部门，或者全局的数据，这些限制会直接在用户中心进行配置，项目代码里请不要出现基于用户的数据过滤逻辑
* 某个页面是否可以被访问
* 某个表、某个字段是否可以被访问，是否可以更新等等

举例：

```
// 错误：在代码里hardcode用户相关筛选逻辑
<messageTable>.select([["_user","eq",SYSENV.currentUser.userId]],[["_update","desc"]],[offset,limit],null) -> _result

//正确：代码里只管业务逻辑，用户相关的数据范围权限，留给权限配置模块
<messageTable>.select(null,[["_update","desc"]],[offset,limit],null) -> _result
```

# VL基础组件列表

## 1. 前端组件

前端组件，可在Section、Component与App文件中使用。注意，部分组件仅可在Section/Component或仅可在App中使用，无特殊说明的组件，可在Section/Component和App中同时使用。

### 前端功能性组件（无UI）

所有功能性组件，尽管无UI，但可以有多个实例，务必在 `# Frontend Tree`（组件树）中定义后方可使用。

#### Trigger (前端定时触发器)

前端定时触发器。

**属性：**

- `repeatTimes(INT)`: 设置触发器最多可播放的次数。设置为 **-1** 表示无限次播放。默认值为 **-1**。
- `interval(FLOAT)`: 设置触发器两次播放之间的时间间隔，以秒为单位。该值为""时则为每一帧（取决于设备刷新率，通常为1/40秒或1/60秒），此时效果接近连续触发。
- `autoPlay(BOOL)`: 控制触发器是否自动播放。设置为true时启用自动播放，设置为false时禁用自动播放。默认值为false，即不自动播放。
- `isAnimate(BOOL)`: 动画优化：使用触发器创建动画时默认开启。开启后，触发器会通过requestAnimationFrame自动适配设备帧率，提供最佳动画效果。关闭时，触发器将严格按照setTimeout定义的时间间隔触发，适用于需要在浏览器非活动标签页中运行的功能。

**方法：**

- `play()`: 激活触发器的播放功能。若触发器当前未播放（或已重置），则从头开始播放；若处于暂停状态，则从暂停点继续播放。
- `pause()`: 使触发器暂停当前播放。再次播放时，将从暂停位置继续播放。
- `stop()`: 触发器停止并恢复到初始状态，清除所有播放进度和暂停状态记录。

**事件：**

- `@tick(counts, interval, duration)`: 当触发器触发时触发，可添加任意动作，当触发器触发时便会去执行触发器内的动作

#### WindowEventListener（浏览器window事件监听器）

监听所有 window 对象支持的事件。注意，所有事件请使用react风格的小驼峰写法，比如：`@keydDown()` , `@hashChange()` , `@beforeUnload()`

#### FrontendApi (前端API 请求客户端，仅Section/Component)

前端 API 请求客户端组件。此组件本身不具备 UI，仅用于封装 API 请求的配置和触发逻辑。

**属性：**

* `url(STRING)`: 必填。API地址，支持路径参数如 `/users/{id}`
* `method(STRING)`: 可选。HTTP方法，默认"GET"
* `headers(OBJECT)`: 可选。默认请求头
* `timeout(INT)`: 可选。请求超时时长（秒）
* `params:(...)`: 可选。用于send()方法的参数类型声明，如 `params:(page(INT),size(INT))`
* `returns:(...)`: 可选。返回值类型声明，如 `returns:(success(BOOL),data([{}]))`

**方法：**

* `send(param1, param2, ...)` - 智能参数分配（推荐）
  * **描述**：根据HTTP方法自动分配参数位置
  * **分配规则**：

    * GET/DELETE: 所有参数 → URL查询参数
    * POST/PUT/PATCH: 所有参数 → 请求体
    * 路径参数（如URL中的 `{id}`）: 自动识别并替换
  * **返回值**：`{success(BOOL), message(STRING), data(JSON)}`
  * **示例**：

    ```vl
    <FrontendApi-GetUsers "getUsersApi"> url:"/api/users" method:"GET" params:(page(INT),size(INT)) returns:(success(BOOL),users([{}]))

    <Button-Load "loadButton">.@click()
    -<FrontendApi-GetUsers "getUsersApi">.send(1, 20) -> _result
    # 实际请求：GET /api/users?page=1&size=20
    ```

    ```vl
    <FrontendApi-CreateUser "createUserApi"> url:"/api/users" method:"POST" params:(name(STRING),email(STRING)) returns:(success(BOOL),userId(INT))

    <Button-Create "createButton">.@click()
    -<FrontendApi-CreateUser "createUserApi">.send("John Doe", "JohnDoe@gmail.com") -> _result
    # 实际请求：POST /api/users，Body: {"name":"John Doe","email":"JohnDoe@gmail.com"}
    ```

    ```vl
    <FrontendApi-UpdateUser "updateUserApi"> url:"/api/users/{id}" method:"PUT" params:(id(INT),name(STRING)) returns:(success(BOOL))

    <Button-Update "updateButton">.@click()
    -<FrontendApi-UpdateUser "updateUserApi">.send(123, "Jane Doe") -> _result
    # 实际请求：PUT /api/users/123，Body: {"name":"Jane Doe"}
    ```
* `customSend(headers?, body?, params?, url?, timeout?, method?)` - 完全自定义
  * **描述**：用于需要精细控制请求参数的复杂场景
  * **参数**：
    * `headers(OBJECT)`: 可选。自定义请求头
    * `body(JSON)`: 可选。请求体
    * `params(OBJECT)`: 可选。URL查询参数
    * `url(STRING)`: 可选。覆盖默认URL
    * `timeout(INT)`: 可选。覆盖默认超时
    * `method(STRING)`: 可选。覆盖默认方法
  * **返回值**：`{success(BOOL), message(STRING), data(JSON)}`
  * **示例**：
    ```vl
    <FrontendApi-SearchUsers "searchApi"> url:"/api/users/search" method:"POST" returns:(success(BOOL),users([{}]))

    <Button-Search "searchButton">.@click()
    -<FrontendApi-SearchUsers "searchApi">.customSend(null, {keyword:"John Doe"}, {page:1,size:20}, null, null, null) -> _result
    # 实际请求：POST /api/users/search?page=1&size=20，Body: {"keyword":"John Doe"}
    ```

**核心使用规则**

* 仅当 `send`方法无法满足需求时，才使用 `customSend`，**仅限**以下场景：
  * POST/PUT/PATCH需要URL参数时
  * 需要额外设置header参数时
  * 动态URL或请求方法时

#### ClientUserCenter（用户中心客户端）

前端用户中心客户端。需要在组件树中声明，如 `<ClientUserCenter-UserAuth>`，通常一个文件仅需要声明一个实例。

**方法：**

* `userLoginPassword(userName, password)`: 用户名密码登录
  * 参数：
    * `userName(STRING)`: 用户名
    * `password(STRING)`: 密码
  * 返回值：
    * `isSuccess`
    * `failReason`
* `userLogout()`: 退出登录
  * 返回值：
    * `isSuccess`
    * `failReason`
* `jumpToUserCenter()`: 跳转至用户中心
* `sendRegistrationSMS(phoneNumber)`: 发送短信验证码
  * 参数：
    * `phoneNumber(STRING)`: 手机号
  * 返回值：
    * `isSuccess`
    * `failReason`
* `registerUser(userName, password, verificationCode, phoneNumber)`: 注册用户
  * 参数：
    * `userName(STRING)`: 用户名
    * `password(STRING)`: 密码
    * `verificationCode(STRING)`: 短信验证码
    * `phoneNumber(STRING)`: 手机号
  * 返回值：
    * `isSuccess`
    * `failReason`

**事件：**

* `@loginDone()`: 登录完成时触发

### 基础UI组件（仅Section/Component）

所有基础UI组件仅在Section/Component中添加，App中不能添加。

**!!注意:** 除了 `<ButtonContainer>`组件，其他基础UI组件都不能添加子组件！

**!!注意:** 固定 css 样式"段是**说明性描述**，**不可在 VL 代码中覆写 `display`**；

#### Text (基础文本)

**属性：**

- `value(STRING)`: 文本内容

**固定css样式：**

display：block

#### Button(基础按钮)

**属性：**

- `value(STRING)`: 按钮文本
- `disabled(BOOL)`: 是否禁用

**固定css样式：**

* display：inline-block

#### ButtonContainer(按钮容器)

通过添加子组件来制作复合按钮，比如一个Icon和一个Text构成的按钮。注意：ButtonContainer本身不能直接设置value属性，所有内容都通过其子组件来呈现。

**属性：**

- `disabled(BOOL)`: 是否禁用

**固定css样式：**

* display：inline-flex

##### Button 组件的使用问题

正确的 VL 形式：

```vl
-<ButtonContainer-PrevMonthBtn> "preMonthButton" ariaLabel:"Previous Month" StyleClass:".."
--<StateStyle-PrevBtnHover> trigger:"hover" background-color:"#f5f5f5"
--<Row-Center> StyleClass:".."
---<Icon-PrevIcon> svgCode:'<svg xmlns="http://www.w3.org/2000/svg" width="18px" height="18px" fill="currentColor" viewBox="0 0 256 256"><path d="M165.66,202.34a8,8,0,0,1-11.32,11.32l-80-80a8,8,0,0,1,0-11.32l80-80a8,8,0,0,1,11.32,11.32L91.31,128Z"></path></svg>' width:"18px" height:"18px"
```

Button 组件下不能添加子组件，需要换用 ButtonContainer

#### Image（基础图片）

**属性：**

- `sourceUri(STRING)`: 图片资源地址。如果需要占位图，请在 `<Image sourceUri:"...">` 中统一使用 **unsplash.com** 的图片地址。

**固定css样式：**

display：inline-block

#### Video（基础视频）

**属性：**

- `sourceUri(STRING)`: 视频资源地址（请按VL规范使用合法的外部资源地址）

**固定css样式：**

display：inline-block

#### Divider (分割线)

用于分隔内容的视觉元素

**属性：**

- `orientation(STRING)`: 分割线方向，可选值："horizontal"、"vertical"，默认为"horizontal"。

**固定css样式：**

display：block

#### Input (基础输入)

基础文本输入

**默认css样式：**

display：inline-block

**属性：**

- `value(STRING)`: 输入框内容。**注意：此属性主要用于设置初始值，并不能实时反应用户输入的内容。**
- `disabled(BOOL)`: 是否禁用输入
- `type(STRING)`: 基础输入，仅支持以下type：text,email,password,number,url,tel其他输入类型请使用对应的扩展组件

**事件：**

- `@change(newValue, oldValue)`: 输入框失焦时，如果内容和聚焦时不同，会触发此事件。抛出旧值和新值。
- `@focus()`: 输入框获得焦点时触发
- `@blur(current)`: 输入框失去焦点时触发
- `@input(newValue, delta)`: 输入内容变化时触发
- `@clickOutside()`: 点击输入框外部区域时触发

#### Textarea（多行输入框）

基础多行输入框组件

**属性：**

同基础单行输入框

**事件：**

同基础单行输入框

**默认css样式：**

display：inline-block

#### Icon (图标)

用于呈现svg，外部资源URL或基于font awsome库的图标。图标请统一使用此组件。图标资源来源可以是 svgCode、url 或 Font Awesome（`fontSet+content`），优先级依次为 **svgCode > url > fontSet+content**。

**属性：**

* `svgCode(STRING)`: 直接指定svg代码
* `url(STRING)`: 外部资源url，VL内部会使用html的mask功能将其转换成图标

- `fontSet(STRING)`: font awsome中的图标库，可选:
  - fa-solid-900
  - fa-regular-400
  - fa-brands-400
- `content(STRING)`: Font Awesome中图标对应的**Unicode字符码**，例如 `"f170"`。**注意**：此值**必须**是图标的Unicode码，**不能**是CSS类名（如 `"fas fa-book"`）或图标名称（如 `"book"`）。如果设置错误，将无法显示图标，而是可能看到类似"OOK"的文本。

**固定css样式：**

display：inline-block

**注意事项：**

* 当icon的内容通过svgCode或url指定时，其大小请通过CSS样式width/height来指定
* 当icon的内容通过fontSet+content指定时，其本质是一个文本，其大小请通过CSS样式font-size来指定（CSS样式放在尖括号外），比如 `<Icon-User fontSet:"fa-solid-900" content:"f007"> fontSize:"16px"`

#### Chart (图表)

图表可视化组件

**属性：**

- `option({})`: 用于ECharts图表渲染的标准option配置示例数据:

  ```json
  {
    "title": { "text": "Data Analysis Chart", "left": "center" },
    "tooltip": { "trigger": "axis" },
    "xAxis": { "type": "category", "data": ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"] },
    "yAxis": { "type": "value" },
    "series": [{
      "name": "Visits",
      "type": "line",
      "data": [150, 230, 224, 218, 135, 147, 260],
      "itemStyle": { "color": "#5470c6" }
    }]
  }
  ```

  当option赋值为上述数据时，会创建一个周访问量折线图

#### MarkdownEdit (Markdown编辑器)

用于编辑Markdown格式文本的组件。注意：markdown编辑器自带工具栏（比如字体，标题，嵌入等工具图标），不需要额外实现UI设计图中的工具栏。

**属性：**

- `value(STRING)`: 编辑器的Markdown文本内容
- `disabled(BOOL)`: 设为true时禁止编辑，默认为false
- `placeholder(STRING)`: 内容为空时显示的文本提示

**事件：**

- `@change(newValue,oldValue)`: 失焦后且内容和之前的内容有所改变。
- `@focus()`: 编辑器获得焦点时触发
- `@blur()`: 编辑器失去焦点时触发
- `@select(value)`: 编辑器中选中文字后触发

#### Markdown (Markdown渲染器)

用于将Markdown文本渲染为HTML并展示的组件

**属性：**

- `value(STRING)`: 需要渲染的Markdown文本内容

### 布局容器组件

**display 规则**：所有容器的 `display` 由组件内置控制，**禁止**通过样式属性直接设置

！所有布局容器，仅用于布局，没有value属性，不可以内置文本

#### Block(基础布局容器)

display为block的布局容器

#### Modal (弹出层)

Modal 由**外层全屏 flex 容器**与**内层 block 内容容器**组成：外层负责蒙层与定位，不可改 `display`；内层用于承载内容（block）。注意，Modal组件上添加的宽、高、背景颜色等样式属性属性，仅用于控制内层容器的宽高，外层flex容器是全屏容器（作为蒙层），不能设置宽高，颜色等css样式。

**属性：**

- `mask(BOOL)`: 是否开启背景蒙层。如果开启，则自动生成一个覆盖全屏的背景蒙层，默认蒙层颜色为黑色(#000000)
- `maskColor(STRING)`: 启用背景蒙层后，可以设置蒙层颜色，默认黑色#000000
- `placement(STRING)`: 横幅相对于当前窗口所处的整体布局，可选值："topLeft"、"topCenter"、"topRight"、"middleLeft"、"middleCenter"、"middleRight"、"bottomLeft"、"bottomCenter"、"bottomRight"，默认为"middleCenter"

**特有事件：**

- `@clickMask()`: 当点击组件的遮罩层时触发（需启用"背景蒙层"属性）。

对于 `modal`组件，其背景蒙层效果应优先通过组件的 `mask:true`和 `maskColor:"rgba(0,0,0,0.5)"`功能属性来控制。避免为 Modal 组件本身设置 `position:fixed`, `top:0`, `left:0`, `background-color` 等用于实现蒙层效果的样式，除非需要高度自定义的蒙层行为。

#### Col、Row、Grid （flex列，flex行，网格容器）

固定使用flex布局和grid布局的容器。

- Col：flex列，display固定为flex，flex-direction默认为column，但可以设置为column-reverse；
- Row：flex行，display固定为flex，flex-direction默认为row，但可以设置为row-reverse；
- Grid：网格容器，display固定为grid

#### Table、TableHeader、TableRow、TableCell、TableCellContainer（表格系列组件，仅Section/Component）

用于制作html表格：

* Table（基础表格容器）：对应 table标签，会为其下直接添加的TableRow组件自动创建tbody标签，不需要额外添加tbody组件
* TableHeader：对应thead标签
* TableRow：对应tr标签，可以直接添加在Table下，或添加在TableHeader下
* TableCell、TableCellContainer：仅能添加在TableRow组件下。当添加在TableHeader的TableRow下时，对应th标签；添加在Table下的TableRow下时，对应td标签。
  * 核心属性
    * rowspan和colspan: 指定其跨越的单元格
  * 内容模式：
    * TableCell组件仅能通过Value属性，指定其文本内容，**不可以添加子组件**
    * TableCellContainer组件**没有Value属性**，但可以添加子组件来呈现内容

**强制层级关系:**

```
<Table>
-<TableHeader-Xx> (可选)
--<TableRow-Xx>
---<TableCell-Xx> value:"Header 1"> 或 <TableCellContainer-Xx>...
--<TableRow-Xx>
---<TableCell-Xx> value:"Data 1" 或 <TableCellContainer-Xx>...
```

**示例:**

```
# Frontend Tree

<Table-UserList> border-collapse:"collapse" width:100%
-<TableHeader-Header>
--<TableRow-HeaderRow>
---<TableCell-HId> value:"ID" styleClass:..
---<TableCell-HName> value:"Name" styleClass:..
---<TableCell-HAction> value:"Action" styleClass:..
-<For-UserRows> sourceArray:$userList loopVar:[_user, _index0]
--<TableRow-UserRow>
---<TableCell-CellId> value:_user.id styleClass:..
---<TableCell-CellName> value:_user.name styleClass:..
---<TableCellContainer-CellAction> styleClass:.. // 使用 TableCellContainer 来放按钮
----<Button-Delete> value:"Delete"
```

### 结构容器组件（仅App）

#### Page 组件

应用的页面容器，负责路由映射和页面生命周期管理。

**属性:**

- `path(STRING)`: 页面的路由路径，逻辑路径标识符，不含前导斜杠

**事件:**

- `@init()`: 页面初始化完成时触发，应用逻辑入口常在此

**使用示例:**

```vl
# Frontend Tree
<Stage-Root>
-<Page-MainPage> "mainPage" path:"main"

# Frontend Event Handerls
<Page-MainPage "mainPage">.@init()
```

**重要规则:**

- `<Page>` 组件必须直接放在 `<Stage>` 标签下
- `<Page>` 不能被嵌套在任何其他容器内部
- `<Page>` 不能包含其他的 `<Page>` 组件

### 逻辑容器组件

逻辑容器组件本身不带UI，不能用于排版布局，**不能添加Style样式（属性行尖括号外为空）**， 另外，由于逻辑容器不能在后续方法中被访问，因此**没有id属性**

#### For (循环容器，仅Section/Component)

根据数据源动态创建重复组件的容器

**属性：**

- `sourceArray(ARRAY)`: 设定循环创建的数据来源，可以是一维数组、二维数组、对象数组等数组变量
- `loopVar([STRING, STRING])`: 定义在每次循环中代表当前数组元素和索引的变量名。格式为 `[_itemVar, _indexVar]`，例如 `[_item0, _index0]`。这两个变量可以在循环容器的子组件中直接使用。

**语法:**

```
<For-任意名称> sourceArray:数组变量 loopVar:[_itemX, _indexX]
-<针对每个数组元素渲染的子组件1>
-<针对每个数组元素渲染的子组件2>
```

**说明:**

* `For-` 是固定前缀，后面跟随一个任意的、描述性的名称（符合组件ID命名规范，PascalCase）。
* `sourceArray` 和 `loopVar` 属性**必须**放在尖括号 `<...>` 内部。`sourceArray` 的值若是变量则无需括号，`loopVar` 的值是字面量数组也无需括号。
* `sourceArray` 属性指定要遍历的数组变量（通常是全局变量 `$var` 或局部变量 `_var`）。
* `loopVar` 属性定义了在每次循环中代表当前数组元素和索引的变量名。

  * `loopVar` 的值是一个包含两个字符串元素的数组 `[循环项变量名, 索引变量名]`。
  * 循环项变量名和索引变量名必须使用下划线 `_` 前缀和 camelCase 命名法。
  * 推荐的命名惯例：
    * 对于索引变量，建议使用 `_indexX` 的形式，其中 X 是一个从0开始的数字，用于区分嵌套循环（例如，第一层是 `_index0`，嵌套的第二层是 `_index1`）。
    * 对于循环项变量，可以使用描述性名称（如 `_user`, `_product`, `_noteItem`）以增强代码可读性，或者在通用迭代场景下使用 `_itemX`（如 `_item0`, `_item1`, `_item2`）。例如: `FOR (_user, _index0) IN $userList` 或 `FOR (_item0, _index0) IN dataArray`。
* 在 `<For-name>` 内部的子组件及其属性中，可以通过 `loopVar` 定义的变量名访问当前循环的元素和索引。
* **最佳实践**: 当 `# Frontend Tree` 中需要渲染列表项时，**必须**使用 `<For-name>`。在列表项上注册的事件处理器中，如果需要引用当前项的数据或索引，**必须**使用 `<For-name>` 中 `loopVar` 定义的变量 (e.g., `_item0`, `_index0`)。避免手动平铺列表项，然后在事件处理器中错误地引用不存在的循环变量。
* **循环变量作用域**: 循环变量 (`_itemX`, `_indexX`) 仅在 `<For-name>` 容器的直接子组件及其后代组件的属性绑定、条件表达式和事件处理器中有效。在 `<For-name>` 外部，或在非 `<For-name>` 内部静态定义的组件事件处理器中，引用这些循环变量是错误的。

**示例:** (渲染一个用户列表)

```
# Frontend Global Vars
$userList([{id:INT,name:STRING,age:INT}]) = [{id:1,name:"Alice",age:30},{id:2,name:"Bob",age:25}]

# Frontend Tree
<Block-UserListContainer>
-<For-UserItems> sourceArray:$userList loopVar:[_item0, _index0]
--<Block-UserItem> // UserItem 是 For 循环的直接子组件
---<Text-UserName> value:("Name: " + _item0.name)
---<Text-UserAge> value:("Age: " + _item0.age)
---<Button-SelectUser "selectButton"> value:"Select" // 假设此按钮有事件处理器
---<If-IsAdult> conditions:(_item0.age >= 18)
----<Icon-AdultIcon> content:"f007"

# Frontend Event Handlers

// 事件处理器，如果 <Button-SelectUser> 是 <For-UserItems> 的一部分
// 并且事件在循环项上注册
<Button-SelectUser "selectButton">.@click() // 假设这个按钮是动态生成的 UserItem 的一部分
-logMessage(("Selected user ID: " + _item0.id + " at index: " + _index0)) // 正确: _item0, _index0 在此事件处理器中有效，因为事件源在循环内部
```

**结合使用 `<If-name>` 和 `<For-name>`:**

```
# Frontend Global Vars

$products([{id:INT, name:STRING, price:FLOAT, stock:INT}]) = [{id:101, name:"Laptop", price:1200.00, stock:5}, {id:102, name:"Mouse", price:25.50, stock:0}]

# Frontend Tree

<Block-ModuleRoot "root">
-<For-ProductCards> sourceArray:$products loopVar:[_item0, _index0]
--<Block-ProductCard>
---<Text-ProductName> value:_item0.name
---<Text-ProductPrice> value:("$" + _item0.price._formatPrice())// Assume PIPE exists
---<If-InStock> conditions:(_item0.stock > 0)
----<Text-StockStatus> value:("In Stock (" + _item0.stock + ")")
----<Button-AddToCart "addButton"> value:"Add to Cart"
---<If-OutOfStock> conditions:(_item0.stock <= 0)
----<Text-StockStatus> value:"Out of Stock"
----<Button-NotifyMe "notifyButton"> value:"Notify Me"
```

**注意:**

* `<If-name>` 和 `<For-name>` 主要用于组件树中控制组件的渲染逻辑。
* 在组件树中，如果只需要根据条件来渲染同一个组件的不同的样式，请使用**条件样式** (`<StateStyle>`) 而不是 `<If-name>`，后者仅用来条件渲染不同结构的组件树。

#### If (条件容器)

根据条件表达式决定是否渲染内容的容器组件

**属性：**

- `conditions(BOOL)`: 条件容器的判断条件表达式，只有满足设置的条件（表达式返回true）才会渲染本容器下的元素

**语法:**

```
<If-任意名称> conditions:(布尔表达式)
-<需要条件渲染的子组件1>
-<需要条件渲染的子组件2>
```

**说明:**

* `If-` 是固定前缀，后面跟随一个任意的、描述性的名称（符合组件ID命名规范，PascalCase）。
* `conditions` 属性接收一个返回布尔值的表达式。此属性**必须**放在尖括号 `<...>` 内部。
* 仅当 `conditions` 表达式的结果为 `true` 时，`<If-name>` 内部的子组件才会被渲染。
* `conditions` 表达式可以引用全局变量 (`$var`)、局部变量 (`_var`)，尤其可以引用循环中的**循环变量** (`_itemX`, `_indexX`)，以及系统变量 (`SYSENV.xxx`)。
* **核心原则警告**: `<If-name>` **绝不能**被用于根据设备类型（如PC或手机）来切换不同的UI布局。这严重违反了"一个应用，一个目标设备"的设计哲学。此组件的 `conditions` 属性**必须**反映应用的**业务逻辑状态**（例如，用户是否登录、数据是否有效、是否处于编辑模式等），而不是设备环境。
  * **错误用法 (严禁)**: `<If-name conditions:(SYSENV.deviceType == 'mobile')>`
  * **正确用法 (推荐)**: `<If-name conditions:($formData.isValid && SYSENV.currentUser.isLogin)>`
  * **正确用法 (推荐，含比较运算符)**: `<If-name conditions:($user.points > 100)>`

**示例:**

```
<Block-UserStatus>
-<If-IsAdmin> conditions:($currentUser.role == "admin")
--<Text-AdminLabel> value:"Admin"
-<If-IsGuest> conditions:($currentUser.role == "guest")
--<Text-GuestLabel> value:"Guest"
-<If-IsLoggedIn> conditions:(SYSENV.currentUser.isLogin && ($userPermissions.canEdit || SYSENV.currentUser.isAdmin))
--<Button-EditProfile "editButton"> value:"Edit Profile"
```

#### TreeFor (树形容器，仅Section/Component)

用于展示和处理具有层级结构的数据的容器组件

**属性：**

- `sourceArray(ARRAY)`: 设定树形容器用来展开创建的数据来源，必须是一个对象数组，且其中有一列为当前节点ID，另一列为父节点ID
- `idField(STRING)`: 数据来源对象数组中，当前节点ID对应的字段，如果是从数据库中输出的数据，通常为"数据ID"
- `pidField(STRING)`: 数据来源对象数组中，父节点ID所对应的字段，此字段值不能为0，如果是顶层，则此字段不填
- `loopVar([STRING,STRING,STRING,STRING,STRING])`定义在每次循环中代表当前数组元素，当前序号，当前层级，展开状态，同级序号的变量名，格式为 `[_itemVar,_indexVar,_levelVar,_expandedVar,_levelIndexVar]`，例如 `[_item0,_index0,_level0,_expanded0,_levelIndex0]`。这些变量可以在树形容器的子组件中直接使用

  * `_itemX`: 当前节点的数据对象。
  * `_indexX`: 当前节点在整个平铺数组中的索引。
  * `_levelX`: 当前节点的层级深度（顶层为0）。
  * `_expandedX`: 布尔值，表示当前节点是否展开。
  * `_levelIndexX`: 当前节点在其同级节点中的索引。

**方法：**

- `expandAllNodes()`: 展开树形容器所有可以展开的节点
- `collapseAllNodes()`: 收起所有展开的节点，只保留最顶层的节点列表
- `expandOneNode(nodeIndex)`: 展开指定节点。
- `collapseOneNode(nodeIndex)`: 收起指定节点。

**语法:**

```
<TreeFor-任意名称> sourceArray:对象数组 idField:"id字段名" pidField:"父id字段名" loopVar:[_itemX, _indexX, _levelX, _expandedX, _levelIndexX]
-<针对每个节点渲染的子组件>
```

### 前端系统方法组件（无需在组件树中声明）

前端系统方法类，全局只有一个实例，无需在组件树中定义即可使用。

#### ClientUtils (前端工具类)

前端通用工具类。

**方法：**

- `delay(milliSecond)`: 设置延时操作，指定毫秒数后执行回调。
- `consoleLog(title,message)`: 在控制台打印调试信息，可指定信息名称方便调试
- `switchRoute(path)`: 切换系统路径，path为字符串，比如"home", “user/info”

#### SysUI (系统UI组件)

前端系统UI方法类。**不要**用 ClientUtils 代替 SysUI 进行弹窗/提示。

**方法：**

- `showModal(title, content)`: 标准样式弹框，可获取到用户的确定或取消结果
  - 返回值：
    - `confirm(BOOL)`: 用户是否点击了确认，返回true/false
    - `cancel(BOOL)`: 用户是否点击了取消，返回true/false
- `showLoading(title)`: 在当前页面中心显示加载图标，显示时无法进行其他操作，通常用于异步操作等待过程
- `hideLoading()`: 隐藏当前页面的加载图标，恢复页面交互能力
- `showToast(message, iconType, customizeIcon, duration)`: 在页面中心显示一个持续一定时间的提示信息，一般用于用户完成某些交互后的反馈提示
- `hideToast()`: 立刻隐藏页面中心的提示语，可用于提前关闭toast

#### SysFile (文件系统组件)

用于前端处理文件上传和下载操作的系统组件

**方法：**

- `uploadImage(url)`: 上传一张图片到服务器，可以在回调中获取图片相关信息，如url地址、名称、类型、大小、分辨率等。
  - 返回值：`url(STRING)`, `name(STRING)`, `type(STRING)`, `size(INT)`, `sizeWithUnit(STRING)`, `progress(INT)`, `failureReason(STRING)`, `resolution(STRING)`, `width(INT)`, `height(INT)`
- `uploadImages(quantityLimit, urls)`: 批量上传图片到服务器(最多20张)，可以在回调中获取图片相关信息。
  - 返回值：`data([{}])`, `urlList([STRING])`, `nameList([STRING])`, `typeList([STRING])`, `sizeList([INT])`, `sizeWithUnitList([STRING])`, `progress(INT)`, `failureReason(STRING)`, `resolutionList([STRING])`, `widthList([INT])`, `heightList([INT])`
- `uploadFile(url, accept)`: 上传一个文件到服务器，可以在回调中获取文件相关信息。
  - 返回值：`url(STRING)`, `name(STRING)`, `type(STRING)`, `size(INT)`, `sizeWithUnit(STRING)`, `progress(INT)`, `failureReason(STRING)`
- `uploadFiles(quantityLimit, urls)`: 批量上传文件到服务器(最多20个)，可以在回调中获取文件相关信息。
  - 返回值：`data([{}])`, `urlList([STRING])`, `nameList([STRING])`, `typeList([STRING])`, `sizeList([INT])`, `sizeWithUnitList([STRING])`, `progress(INT)`, `failureReason(STRING)`
- `downloadFile(fileName, url)`: 下载指定网址的文件到本地
  - 返回值：`success(BOOL)`, `bytesLoaded(INT)`, `progress(INT)`, `failureReason(STRING)`

* `browseImage(outputBase64, compressedWidth, compressedHeight, type, encoderOptions)`: 读取本地图片
  * 描述：读取一张本地图片的信息，返回Base64、名称、类型、尺寸、宽高、临时本地路径、文件对象等信息。
  * 参数：
    * `outputBase64(Boolean)`: **是否输出base64** (是否需要在读取之后转换为base64格式，默认为是。转换为base64，会有一定的性能消耗，如果仅需要显示图片并上传，可以使用临时路径+文件对象的方法，无需输出base64。如果选择输出base64，则返回结果中可引用base64结果（src字段），否则不会返回base64结果。)
    * `type(STRING)`: **输出格式** (选择读取后图片的格式为jpg或png。如果选择jpg，则可以进一步指定图片质量。)
    * `encoderOptions(INT)`: **输出质量** (输出图片的质量，是一个0-1之间的数值。注意，仅当输出图片格式选择为jpg时此选项才有效，png格式为不可压缩格式。)
  * 返回值：
    * `base64Code`: **base64图片** (图片转换为base64格式的资源地址。注意，仅在读取时打开输出base64时，此项才会有结果，否则结果为空。)
    * `name`: **名称** (图片名称。)
    * `type`: **类型** (图片的类型。)
    * `size`: **尺寸** (图片的大小。)
    * `width`: **宽度** (图片的宽度。)
    * `height`: **高度** (图片的高度。)
    * `blobUrl`: **临时本地路径** (图片临时本地路径。)
    * `failureReason`: **读取失败原因** (读取图片失败的原因。)
    * `file`: **文件对象** (读取到的图片文件对象，可用来作为上传图片的文件路径。)
* `browseImages(maxNumberPic, outputBase64, compressedWidth, compressedHeight, type, encoderOptions)`: 读取多张本地图片
  * 描述：读取多张本地图片的信息，返回一个对象数组，每个对象包含的字段包含src,name,type,size,width,height,path,file等信息。
  * 参数：
    * `maxNumberPic(INT)`: **最大图片数** (最多允许一次上传的图片个数。)
    * `type(STRING)`: **输出格式** (选择读取后图片的格式为jpg或png。如果选择jpg，则可以进一步指定图片质量。)
    * `encoderOptions(INT)`: **输出质量** (输出图片的质量，是一个0-1之间的数值。注意，仅当输出图片格式选择为jpg时此选项才有效，png格式为不可压缩格式。)
  * 返回值：
    * `imageList`: **图片列表** (所有被读取的图片的相关信息组成的数组。返回结果是一个对象数组，每个对象包含的字段包含src,name,type,size,width,height,path,file,详见读取一张图片的返回结果说明。)
    * `failureReason`: **读取失败原因** (读取图片失败的原因。)
* `browseFile(outputBase64, accept)`: 读取本地文件
  * 描述：读取一个本地文件的信息，返回名称、类型、尺寸、临时本地路径、base64数据等信息。不支持在微信浏览器、webApp微信小程序、支付宝/钉钉小程序中使用。
  * 参数：
    * `outputBase64(Boolean)`: **转为base64** (默认否，选择是之后，将自动把文件转成base64，此时，可以在回调中选择读取结果的base64串，否则无法读取。)
    * `accept(STRING)`: **可选文件类型** (参数可以限制选择的文件类型，由文件的mimeType构建的字符串，如设置多个，以英文逗号分割，例如："image/\*,application/x-zip-compressed")
  * 返回值：
    * `name`: **名称** (文件名称。)
    * `type`: **类型** (文件的类型。)
    * `size`: **尺寸** (文件的大小。)
    * `blobUrl`: **临时本地路径** (文件临时本地路径。)
    * `base64Code`: **base64数据** (文件的base64格式数据，注意，必须在读取的时候选择base64格式方可读取。)
* `browseFiles(accept, maxNumberFile)`: 读取多个本地文件
  * 描述：读取多个本地文件的信息，返回一个对象数组，每个对象包含名称、类型、尺寸、临时本地路径等信息。不支持在微信浏览器、webApp微信小程序、支付宝/钉钉小程序中使用。
  * 参数：
    * `accept(STRING)`: **可选文件类型** (参数可以限制选择的文件类型，由文件的mimeType构建的字符串，如设置多个，以英文逗号分割，例如："image/\*,application/x-zip-compressed")
    * `maxNumberFile(INT)`: **最大文件数** (最多允许一次上传的文件个数。)
  * 返回值：
    * `fileList`: **文件列表** (所有被读取的文件的相关信息组成的数组。)
    * `failureReason`: **读取失败原因** (读取文件失败的原因。)

#### SysLocalStorage (本地存储)

用于在客户端存储数据的系统组件，支持Cookie、SessionStorage和LocalStorage

**方法：**

- `setCookie(path, domain, maxAge, key, value)`: 为浏览器设置当前域名下的cookie，需要传入Key和对应的值。
- `setCookies(path, domain, maxAge, keyValue)`: 为浏览器设置当前域名下的多个cookie，可传入多对Key和对应的值。
- `getCookie(key)`: 获取当前域名下指定key的cookie值。
- `removeCookie(key)`: 删除当前域名下指定key的cookie。

#### SysDevice (设备访问)

用于前端访问和控制设备硬件功能的系统组件

**方法：**

- `scanCode()`: 调起手机相机进行扫码，返回扫码结果
  - 返回值：
    - `data(STRING)`: 扫码成功获取到的信息。
    - `errMsg(STRING)`: 扫码失败的错误信息。

### 挂件

挂件添加在实体UI组件（基础UI，布局容器等）组件下的额外功能组件，可以为目标实体UI组件提供表单字段处理、动态样式、动画、拖拽、滚动等行为。

#### StateStyle (状态与条件样式组件)

`<StateStyle>` 用于定义其父组件在特定交互状态（如鼠标悬停）或满足特定逻辑条件时应用的样式。它使得动态样式管理更加集中和清晰。

**语法:**

```
<父组件 ...>
-<StateStyle-StateName> trigger:"状态字符串" conditions:布尔表达式 样式1:值 ..
-<StateStyle-StateName> conditions:(布尔表达式) 样式1:值 ..
```

**说明:**

* `<StateStyle>` 必须作为其要影响的UI组件的直接子组件（缩进深一级）。
* **StateStyle组件名称请反应它的用途**，例如 `<StateStyle-HoverEffect>`。
* 一个父组件可以有多个 `<StateStyle>` 子组件，用于处理不同的状态和条件。
* `<StateStyle>`的样式属性**不允许使用属性表达式**，只能使用字面值或css原生的calc表达式。
* `trigger` 和 `conditions` 属性是功能性属性。
  * **`trigger` 属性**: 接收一个特定的字符串，用于响应UI的内置交互状态，其值对应CSS中的各种伪类（pseudo-classes）和部分伪元素（pseudo-elements）。常见的值包括"hover","active","focus","disabled"等等；
  * **`conditions` 属性**: 接收一个返回布尔值的表达式。当表达式为 `true` 时，样式被应用。这允许基于任意应用状态（如 `$isInvalid`, `$nightTheme == 'dark'`）来改变样式。

**示例:**

```
<ButtonContainer-Submit> disabled:(!$canSave) StyleClass:".."
-<Text-SubmitLabel> value:"Submit"
-<StateStyle-HoverEffect> trigger:"hover" background-color:"#2980b9" // 悬停时变深
-<StateStyle-DisabledState> trigger:"disabled" background-color:"#bdc3c7" cursor:"not-allowed" // 禁用时样式
-<StateStyle-ErrorBorder> conditions:$formHasError border-width:"2px" border-style:"solid" border-color:"#e74c3c" // 错误时样式
```

#### Animation (动效)

作为目标UI组件一个"挂件"，为其添加动画效果。添加之后，VL系统会自动在目标UI元素外部包裹一层透明的Div以实现动画效果。

**Properties (属性)**

* **animationName (动效类型)**

  * **描述：** 从系统默认动效库中选取动效类型，共分为强调动效、入场动效、出场动效三大类，可根据实际场景选取。每种动效有多种效果可选，每种效果可能具有多个方向。
  * **Options (可选值)：**

    * 强调类: bounce,flip,flash,jello,pulse,rubberBand,shake,swing,tada,wobble,hinge,rotateC,rotateAC;
    * 进入类: fadeIn,fadeInDown,fadeInUp,fadeInLeft,fadeInRight,bounceIn,bounceInDown,bounceInUp,bounceInLeft,bounceInRight,rotateIn,rotateInDownLeft,rotateInUpLeft,rotateInDownRight,rotateInUpRight,slideInDown,slideInUp,slideInLeft,slideInRight,zoomIn,zoomInDown,zoomInUp,zoomInLeft,zoomInRight,flipInX,flipInY,rollIn;
    * 退出类：fadeOut,fadeOutDown,fadeOutUp,fadeOutLeft,fadeOutRight,bounceOut,bounceOutDown,bounceOutUp,bounceOutLeft,bounceOutRight,rotateOut,rotateOutDownLeft,rotateOutUpLeft,rotateOutDownRight,rotateOutUpRight,slideOutDown,slideOutUp,slideOutLeft,slideOutRight,zoomOut,zoomOutDown,zoomOutUp,zoomOutLeft,zoomOutRight,flipOutX,flipOutY,rollOut;
* **duration (动画时长(秒))**

  * **描述：** 动效的动画持续时间，单位秒。
* **delay (启动延时(秒))**

  * **描述：** 动效的启动延时，单位秒。
* **iterationCount (播放次数)**

  * **描述：** 动效每次触发后的播放次数，默认为1，即播放1次即停止。
* **loop (循环播放)**

  * **描述：** 通过开关控制动效的循环播放，默认不开启。
* **playAnimate (预览动效)**

  * **描述：** 点击按钮预览当前动效的效果。
* **trigger (触发时机)**

  * **描述：** 触发当前动效的方式。
  * **Options (可选值)：**
    * **onRender (自动播放)：** 进入。
    * **onHide (对象隐藏时)：** 离开。
    * **onClick (点击)：** 点击。
    * **onHover (鼠标移入)：** 鼠标移入。
    * **custom (手动调用)：** 手动调用。
* **initialVisibility (开始前隐藏)**

  * **描述：** 在动效触发前是否隐藏添加了当前动效的组件。
* **editAnimate (编辑动效)**

  * **描述：** 点击按钮可以打开动效编辑器，编辑当前动效。
* **hideAfterCompletion (结束后隐藏)**

  * **描述：** 动效结束后是否隐藏添加了当前动效的组件。可用于离场式的动效。

**Methods (方法)**

* **play (重新播放)**
  * **描述：** 从头播放当前动效组。请注意，动效组是一个整体；每次播放都会从头开始，这与时间轴动画不同，时间轴动画在暂停后会从暂停处继续播放。
* **stop (停止播放)**
  * **描述：** 停止当前动效组的播放。

#### AnimationGroup (动效组)

`data-animate-group` 组件用于管理一组动效的触发和播放，其本身是一个容器，其下只能添加动效组件。

**Properties (属性)**

* **trigger (触发时机)**
  * **描述：** 选择动效组何时触发，默认为自动播放。您还可以选择点击、鼠标移入等，这相当于添加了一个自动事件。当然，也可以选择"手动调用"，这样就需要通过事件面板来控制其触发。
  * **Options (可选值)：**
    * **onRender (自动播放)：** 对象进入/加载时触发。
    * **onHide (对象隐藏时)：** 对象通过动作设置为不可见时触发。
    * **onClick (点击)：** 点击对象时触发。
    * **onHover (鼠标移入)：** 鼠标移入对象时触发。
    * **custom (手动调用)：** 手动通过其他事件动作调用触发。
* **initialVisibility (开始前隐藏)**
  * **描述：** 指定动效组开始前是否隐藏对象。
* **hideAfterCompletion (结束后隐藏)**
  * **描述：** 指定动效组结束后是否隐藏对象。

**Methods (方法)**

* **play (重新播放)**
  * **描述：** 从头播放当前动效组。请注意，动效组是一个整体；每次播放都会从头开始，这与时间轴动画不同，时间轴动画在暂停后会从暂停处继续播放。
* **stop (停止播放)**
  * **描述：** 停止当前动效组的播放。

#### UseDraggable (拖动源挂件，仅Section/Component)

useDraggable 赋予任何其挂载的父UI组件被拖动作为拖动源的能力。它管理拖动开始时的数据设置和拖动结束时的状态清理。拖拽操作为复杂用户交互操作，仅能在Section/Component中添加使用。

**核心事件**

* **@dragStart** 当用户开始拖动挂载了此挂件的元素时触发。这是唯一可以在 `dataTransfer` 上调用 `setData()` 的时机。同时，挂件会设置 `event.dataTransfer.effectAllowed` 来声明允许的拖动操作类型，这会影响拖动时的鼠标光标样式。
* **@dragEnd** 拖动操作结束时触发，无论放置成功、取消或放置在无效区域。事件会抛出 `event.dataTransfer.dropEffect` 参数，用来判断拖放操作的最终结果。

#### UseDropTarget (放置目标挂件，仅Section/Component)

useDropTarget 赋予任何其挂载的父UI组件作为放置目标（即接收拖放操作）的能力。用于管理放置区域的高亮状态和放置事件的数据提取。

**核心事件**

* **@dragEnter** 当拖动中的元素首次进入挂载了此挂件的组件区域时触发。挂件内部**自动调用 `event.preventDefault()`**。同时，抛出 `event.dataTransfer.types` 来检查拖动数据类型是否可接受。
* **@dragOver** 当拖动中的元素在挂载了此挂件的组件区域内移动时持续触发。**触发时请务必调用 `event.preventDefault()`**，以允许 `drop` 事件触发的关键。同时，它会写入 `event.dataTransfer.dropEffect` 来设置该区域偏好的操作类型，这会影响鼠标光标样式。
* **@dragLeave** 当拖动中的元素离开挂载了此挂件的组件区域时触发。
* **@drop** 当用户在挂载了此挂件的组件区域上方释放鼠标按键时触发。挂件内部会调用 `event.preventDefault()`，读取 `event.dataTransfer.getData()` 获取拖动源传递的数据。

#### 组件拖拽事件注册问题

拖拽相关的事件必须注册在对应的拖拽插件上，而不是注册在普通组件上：

**示例：：**

```vl
<Section-SortableList "root">

# Frontend Global Vars
$draggedIndex(INT) = -1
$items([{id:INT,text:STRING}]) = [{id:1,text:"项目A"},{id:2,text:"项目B"},{id:3,text:"项目C"}]

# Frontend Tree
<Block-ModuleRoot>
-<Col-ListContainer>
--<For-Items> sourceArray:$items loopVar:[_item0,_index0]
---<Block-Item draggable:true> StyleClass:".."
----<UseDraggable-ItemDrag "dragItem">
----<UseDropTarget-ItemDrop "dropTarget">
----<StateStyle-Dragging> conditions:(_index0 == $draggedIndex) opacity:"0.4"
----<StateStyle-Active> trigger:"active" cursor:"grabbing"
----<Text-ItemText> value:_item0.text

# Frontend Event Handlers

<UseDraggable-ItemDrag "dragItem">.@dragStart()
-$draggedIndex = _index0

<UseDropTarget-ItemDrop "dropTarget">.@dragOver(event)
-event.preventDefault()

<UseDropTarget-ItemDrop "dropTarget">.@drop()
-IF $draggedIndex == -1 || $draggedIndex == _index0
--$draggedIndex = -1
--RETURN
-_draggedItem({id:INT,text:STRING}) = $items[$draggedIndex]
-$items.splice($draggedIndex, 1)
-$items.splice(_index0, 0, _draggedItem)
-$draggedIndex = -1

<UseDraggable-ItemDrag "dragItem">.@dragEnd()
-$draggedIndex = -1

</Section-SortableList>
```

**关键要点：**

1. 拖拽相关的事件（`@dragStart`、`@dragEnd`、`@dragOver`、`@drop`）必须注册在相应的拖拽插件（`<UseDraggable>`、`<UseDropTarget>`）上
2. `@drop`事件要生效，必须先添加 `@dragOver`事件，并在该事件中阻止默认行为
3. 普通组件（如 `<Row-SortableItem>`）不能直接监听拖拽事件

### 模块组件

#### Section（仅App）

在App中使用的当前项目中定义的Section，添加至组件树时，作为一个组件树的组件（比如  `<Section-MySection "mySection"> 属性1:属性值... `）。

注意：Section组件性质类似扩展UI组件，**严禁添加除了挂件之外的子组件**。比如，以下用法是严格禁止的：

```
//错误用法，在Section下添加Section或其他UI组件
<Section-ChatRoomLayout "layoutView">
-<Text-RoomTitle> value:$title //Section下不能添加Text等基础UI组件，Section不是一个容器
-<Section-OnlineUsersPanel "onlinePanel"> // Section下禁止添加其他Section
```

请注意：

* Section的属性/方法/事件，请严格遵守Section的文件定义，**严禁自己发明Section的属性/方法/事件**

#### Component （App或Section）

在App或Section中可使用当前项目中自定义的额外组件，使用 `<Component-ComponentName>`来引入，注意，Component是独立组件，其下不能添加其他非挂件类组件。

### 扩展UI组件 （仅Section/Component）

#### 1. `SingleSelect Group` (单选选择器组)

`SingleSelect Group` 用于处理所有单选场景，其成员组件共享核心逻辑和数据模型，仅在UI和交互上有所不同。

##### Group 通用接口

* **功能说明**: 该组所有组件内部都应实现"清空"功能（例如，通过一个可配置的清空按钮），用户交互触发后，组件将 `value` 设为 `null` 并触发 `onChange` 事件。
* **属性 (Properties)**
  * `options`: `Array<Object>` - 必填。一个包含选项对象的数组。每个对象应包含 `label` (String) 和 `value` (String | Number)。
  * `value`: `String | Number` - 当前选中的选项的 `value`。如果未选中任何项，其默认值为 `null`。
  * `disabled`: `Boolean` - 可选, 是否禁用可选项。
* **方法 (Methods)**
  * `focus()`: 使选择器获得焦点。
  * `blur()`: 使选择器失去焦点。
* **事件 (Events)**
  * `@onChange(newValue)`: 当选中值改变时触发。`newValue` 是选中的选项的 `value`。
  * `@onFocus()`: 当选择器获得焦点时触发。
  * `@onBlur()`: 当选择器失去焦点时触发。

##### 子组件简介与特有接口

1. **`SingleSelect_Dropdown` (下拉单选)**
   * **简介**: PC端常见的下拉菜单样式，用户点击后弹出一个列表供选择。特点是节省空间，鼠标操作友好，常用于选项较多或需要上下文菜单的场景。
   * **特有属性 (Properties)**
     * `placeholder`: `String` - 可选。当没有选中项时显示的占位文本。
   * **特有事件 (Events)**
     * `@onOpen()`: 当下拉菜单被打开时触发。
     * `@onClose()`: 当下拉菜单被关闭时触发。
2. **`SingleSelect_RadioButtons` (单选按钮)**
   * **简介**: 以一组独立的单选按钮形式展示所有选项，用户直接点击选择。特点是直观，所有选项可见，适用于选项数量较少 (如 2-5 个) 的情况。
3. **`SingleSelect_OverlayPicker` (弹层单选选择器)**
   * **简介**: 点击后在屏幕中央或底部以模态弹层/抽屉形式展示选项列表供选择。特点是触控友好，大尺寸选项，适应小屏幕空间，可能内置搜索过滤功能。
   * **特有属性 (Properties)**
     * `placeholder`: `String` - 可选。当没有选中项时显示的占位文本。
   * **特有事件 (Events)**
     * @`onOpen()`: 当弹层被打开时触发。
     * `@onClose()`: 当弹层被关闭时触发。

#### 2. `MultiSelect Group` (多选选择器组)

`MultiSelect Group` 用于处理所有多选场景，其成员组件旨在返回一个数组形式的选中值。

##### Group 通用接口

* **功能说明**: 该组所有组件内部都应实现"清空"功能（例如，通过一个可配置的清空按钮），用户交互触发后，组件将 `value` 设为 `[]` 并触发 `onChange` 事件。
* **属性 (Properties)**
  * `options`: `Array<Object>` - 必填。包含选项对象的数组。每个对象需包含 `label` (String) 和 `value` (String | Number)。
  * `value`: `Array<String | Number>` - 当前选中项 `value` 的数组，默认为空数组 `[]`。
  * `readOnly`: `Boolean` - 可选。是否只读，用户不能修改值。
* **方法 (Methods)**
  * `focus()`: 使选择器获得焦点。
  * `blur()`: 使选择器失去焦点。
* **事件 (Events)**
  * `@onChange(newValues)`: 当选中值数组改变时触发。
  * `@onFocus()`: 当选择器获得焦点时触发。
  * @`onBlur()`: 当选择器失去焦点时触发。

##### 子组件简介与特有接口

1. **`MultiSelect_Dropdown` (下拉多选)**
   * **简介**: PC端常用的多选下拉菜单，点击后展开包含复选框的选项列表。特点是节省空间，适合选项较多的情况。
   * **特有属性 (Properties)**
     * `placeholder`: `String` - 可选。当没有选中项时显示的占位文本。
   * **特有事件 (Events)**
     * `@onOpen()`: 当下拉菜单被打开时触发。
     * `@onClose()`: 当下拉菜单被关闭时触发。
2. **`MultiSelect_Checkboxes` (复选框组)**
   * **简介**: 以一组独立的复选框形式展示所有选项。特点是直观，所有选项可见，适用于选项数量较少的情况。
3. **`MultiSelect_OverlayPicker` (弹层多选选择器)**
   * **简介**: 点击后在屏幕中央或底部以模态弹层形式展示选项列表，每个选项带复选框。特点是触控友好，适应小屏幕空间。
   * **特有属性 (Properties)**
     * `placeholder`: `String` - 可选。当没有选中项时显示的占位文本。
   * **特有事件 (Events)**
     * `@onOpen()`: 当弹层被打开时触发。
     * @`onClose()`: 当弹层被关闭时触发。

#### 3. `BinaryToggle Group` (二元开关组)

`BinaryToggle Group` 用于处理简单的 `true`/`false` 状态切换。

##### Group 通用接口

* **功能说明**: 该组所有组件的状态切换（如打开/关闭）功能完全由组件内部的 UI 交互触发。
* **属性 (Properties)**
  * `checked`: `Boolean` - 当前开关是否为"开"状态，默认为 `false`。
  * `readOnly`: `Boolean` - 可选。是否只读，用户不能修改值。
* **方法 (Methods)**
  * 无
* **事件 (Events)**
  * `@onChange(newCheckedState)`: 当开关状态改变时触发，`newCheckedState` 是新的布尔状态。
  * `@onFocus()`: 当开关获得焦点时触发。
  * @`onBlur()`: 当开关失去焦点时触发。

##### 子组件简介与特有接口

1. **`BinaryToggle_Switch` (滑动开关)**
   * **简介**: 经典的"拨动"式开关，有一个可滑动的拇指（thumb）。
2. **`BinaryToggle_Checkbox` (单复选框)**
   * **简介**: 一个简单的复选框，勾选表示"开"，不勾选表示"关"。

#### 4. `FileUploader Group` (文件上传器组)

`FileUploader Group` 用于所有文件上传场景，核心功能完全封装在组件内部，通过事件向外部报告状态变化。

##### Group 通用接口

* **功能说明**: 文件选择、上传（在文件被选中后自动开始）以及删除功能都由组件内部的 UI 交互触发和控制。
* **属性 (Properties)**
  * `value`: `Array<Object>` - 已上传文件信息的数组，默认为空数组 `[]`。
  * `multiple`: `Boolean` - 可选。是否允许多文件上传，默认为 `false`。
  * `accept`: `String` - 可选。接受的文件类型（如 `.jpg,.png` 或 `image/*`）。
  * `maxSize`: `Number` - 可选。允许上传的最大文件大小（字节）。
  * `readOnly`: `Boolean` - 可选。是否只读，用户不能修改值。
* **事件 (Events)**
  * `@onChange(newFiles)`: 当文件列表改变时触发。
  * `@onUploadSuccess(fileInfo, response)`: 文件上传成功时触发。
  * @`onUploadError(fileInfo, error)`: 文件上传失败时触发。
  * `@onProgress(fileInfo, progressEvent)`: 上传过程中触发进度事件。

##### 子组件简介与特有接口

1. **`FileUploader_Button` (按钮式上传)**
   * **简介**: 一个按钮，点击后触发文件选择对话框和自动上传。
2. **`FileUploader_Dropzone` (拖拽上传区)**
   * **简介**: 一个可视化区域，用户可以将文件拖放到该区域进行上传。
3. **`FileUploader_ImageList` (图片列表上传)**
   * **简介**: 一个集成了文件选择、图片预览和删除功能的列表式上传组件。所有操作（包括删除文件）都在组件内部通过 UI 交互完成。

## 2. 前端组件通用属性/方法/事件

### 通用属性

#### 非只读属性

**以下通用属性适用于所有非结构容器的前端UI组件（基础UI组件、布局容器、扩展UI组件）:**

* **show(BOOL)**:

  * 默认值: true
  * 描述: 当设为false时，组件不会在页面上渲染（等同于display:none）。通常情况下，不需要声明，除非初始状态为false.

#### 只读属性

##### 尺寸属性 (不包含 `transform`)

* **`offsetWidth` / `offsetHeight`**: 元素完整尺寸（内容 + 内边距 + 边框 + 滚动条），当元素没有scale或rotate时，优先使用此属性over `getBoundingClientRect()`方法
* **`clientWidth` / `clientHeight`**: 元素内部可视尺寸（内容 + 内边距），当元素没有scale或rotate时，优先使用此属性over `getBoundingClientRect()`方法
* **`scrollWidth` / `scrollHeight`**: 元素所有内容的完整尺寸（内容 + 内边距）。

##### 相对位置属性

* **`offsetLeft` / `offsetTop`**: 元素相对于**最近定位祖先**的位置。

### 通用事件

!!注意: 并不是所有js原生事件都可以在所有的组件上监听，通用的事件仅包含此文档中列出的部分。

**以下通用事件适用于所有UI组件（前端根组件、基础UI组件、布局容器、结构容器、扩展UI组件）:**

* `@init()`: 组件初始化完成时触发
* `@click(event)`: 点击事件
* `@mouseOn(event)`: 鼠标移入事件
* `@mouseOut(event)`: 鼠标移出事件
* `@mouseDown(event)`: 鼠标按下事件
* `@mouseUp(event)`: 鼠标抬起事件

**以下通用事件适用于布局容器、结构容器：**

* `@scrollToBottom()`: 容器滚动到底部（若为横向排列则为最右侧）时触发
* `@scrollToTop()`: 容器滚动到顶部（若为横向排列则为最左侧）时触发
* `@clickOutside()`: 点击容器外部区域时触发

### 通用方法

**以下方法适用于所有UI组件（基础UI组件、布局容器、结构容器、扩展UI组件）**：

* `focus()、blur()`: 获取/失去焦点，当为某个组件添加这两个方法时，系统会自动将其的tabindex属性设为-1，无需手动指定；
* `getBoundingClientRect()`**: 返回一个对象，包含元素相对于**视口的实时位置和完整尺寸。注意，当可以使用clientWidth/Height, offsetWidth/Height时，请优先使用后者，以减小开销并简化代码。

**以下通用方法适用于所有布局容器、结构容器:**

* `scrollToBottom()`: 滚动至底部，当direction是column时，滚动到最下面，row时，滚动到最右边，依次类推；
* `scrollToTop()`: 滚动至顶端
* `scrollTo(left,top,speed)`: 滚动到某位置，left，top为距左侧和距顶部的距离，speed为1-100的数值，1代表最快，100最慢

## 3. ServiceDomain中使用的组件

所有后台组件，需要先在ServiceDomainRoot组件下创建，才可以使用。（先声明后使用原则）

### 后台数据组件

#### VirtualTable (虚拟表)

用于在后台服务中访问和操作数据库表的组件。

**方法**

| 方法                | 参数                                          | 返回值                                 | 说明                         |
| ------------------- | --------------------------------------------- | -------------------------------------- | ---------------------------- |
| `select`          | conditions, orderBy, outputRows, outputFields | success, message, dataArray, structure | 查询数据                     |
| `insert`          | valueObj({})                                  | success, message, dataId, dataObj      | 插入数据（系统字段自动填充） |
| `update`          | conditions, set, limit                        | success, message, affect               | 更新数据                     |
| `batchUpdateById` | source([{}])                                  | success, message, affect               | 批量按ID更新                 |
| `count`           | conditions                                    | success, message, count                | 统计记录数                   |
| `delete`          | conditions, limit                             | success, message, affect               | 删除数据（建议用逻辑删除）   |

* **条件数组 (conditions)**

  * **格式**: `[[字段, 操作符, 值], ...]`
  * **操作符**: `eq`(=), `neq`(!=), `gt`(>), `gte`(>=), `lt`(<), `lte`(<=), `in`, `nin`, `contains`(%val%), `startsWith`(val%), `endsWith`(%val)
  * **空值忽略**: 操作符前加 `*`（如 `*eq`、`*contains`），当值为null时自动忽略该条件
  * **OR条件**: `["OR", [条件1], [条件2], ...]`
* **排序数组 (orderBy)**

  * **格式**: `[[字段, "asc"/"desc"], ...]`
  * **不排序**: `null`
* **分页数组 (outputRows)**

  * **格式**: `[offset, limit]`
  * **不分页**: `null`
* **更新操作数组 (set)**

  * **格式**: `[[字段, 操作类型, 值], ...]`
  * **操作类型**: `"set"`(设置), `"inc"`(增减), `"mul"`(乘), `"append"`(追加数组)

**快速示例**

```vl
# 查询 - 带条件、排序、分页
<VirtualTable-Users "userTable">.select(
  [["status","eq","active"], ["age","gte",18]],  # 条件：活跃且成年
  [["_create","desc"]],                           # 排序：创建时间降序
  [0, 20],                                        # 分页：前20条
  ["id","name","email"]                           # 字段：仅返回这3个
) -> _result

# 插入 - 系统字段自动填充
<VirtualTable-Users "userTable">.insert({
  name:"John Doe", 
  email:"JohnDoe@gmail.com", 
  joinDate:"2024-01-15 10:00:00"
}) -> _result
# _id, _user, _create, _update 由系统自动填充

# 更新 - 单条记录
<VirtualTable-Users "userTable">.update(
  [["id","eq",123]],           # 条件
  [["name","set","New Name"]],  # 操作
  1                            # 最多更新1条
) -> _result

# 更新 - 多字段 + 递增
<VirtualTable-Articles "articleTable">.update(
  [["id","eq",50]],
  [["viewCount","inc",1], ["status","set","hot"]],  # 浏览数+1，状态改hot
  1
) -> _result

# 批量更新
<VirtualTable-Products "productTable">.batchUpdateById([
  {"_id":101, "price":299, "stock":50},
  {"_id":102, "price":199, "stock":30}
]) -> _result

# 逻辑删除（推荐）
<VirtualTable-Notes "noteTable">.update(
  [["id","eq",noteId]], 
  [["status","set",-1]], 
  1
) -> _result

# 统计
<VirtualTable-Orders "orderTable">.count([["status","eq","pending"]]) -> _result
```

**高级示例**

```vl
# OR条件 + 模糊搜索
<VirtualTable-Posts "postTable">.select(
  [["OR", ["title","contains","VL"], ["content","contains","VL"]], ["status","eq","published"]],
  null, [0,10]
) -> _result

# 空值条件忽略（动态筛选）
<VirtualTable-Users "userTable">.select(
  [["name","*contains",$keyword], ["role","eq","admin"]],  # $keyword为null时自动忽略
  null, [0,20]
) -> _result

# 复杂更新
<VirtualTable-Orders "orderTable">.update(
  [["OR", ["status","eq","pending"], ["status","eq","processing"]], ["createTime","lte","2023-09-01"]],
  [["status","set","canceled"], ["cancelReason","set","过期"]],
  50
) -> _result
```

**注意事项**

* **系统字段**（`_id`, `_user`, `_create`, `_update`）由系统自动管理，insert/update时不可指定
* **时间字段**：可传TIMESTAMP变量或 `"YYYY-MM-DD HH:mm:ss.SSS"` 格式字符串
* **逻辑删除**：推荐用 `update` 设置 `status=-1`，而非物理 `delete`
* **错误处理**：推荐使用系统默认机制（自动处理 `success:false`）

#### ServerCache(缓存表)

缓存表用于缓存数据的读写。与VirtualTable不同，缓存表不需要额外的绑定一个实体表，系统会自动创建与维护对应的缓存数据存储设施。

**方法**

### 后台功能组件

#### ServerApi(后台Api请求端)

属性和方法完全同前端Api请求端组件。

#### MQ（消息队列）

接受服务/方法发送的消息，然后异步处理。用于基础的异步处理以及服务请求的削峰。

**属性**

* struct({}): 消息结构，是一个单层对象，比如：`<MQ-DataStream "dataStream" struct:{structField1:STRING,structField2:INT}>`

**事件**

* @Message(structField1,structField2...): 收到消息事件，在事件主体中可定义消息处理逻辑

**方法**

* send(structField1,structField2...): 向消息队列发送消息，注意消息的结构请严格参照消息队列组件的struct属性。比如：`-<MQ-DataStream "dataStream">.send(_data,_num)`

### 后台系统方法组件（无需在组件树中声明）

后台系统方法类，全局只有一个实例，无需在组件树中定义即可使用。

#### ServerUtils (后台工具类)

在后台服务中可调用的系统方法类。不允许在前端调用。

**方法：**

- `getCurrentTime()`: 获取服务器当前时间，返回服务器系统时间，可用于确保时间同步或获取标准时间。
- `delay(second)`: 在服务器端执行等待操作，暂停指定的秒数。
